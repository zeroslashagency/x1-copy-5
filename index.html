<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Scheduler</title>
    <!-- Add Supabase Auth UI CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@supabase/auth-ui-shared@0.0.11/dist/components.css" />
    <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="excel_export.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid #e1e8ed;
        }

        .card h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.4em;
            font-weight: 600;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        /* Optional Overrides layout tuning */
        #optionalOverridesContent {
            grid-template-columns: repeat(3, minmax(280px, 1fr));
            column-gap: 24px;
            row-gap: 18px;
            align-items: start;
        }
        /* Make the two range groups span two columns so fields are wider */
        #orderBreakdownGroup { grid-column: 2 / span 2; }
        #orderHolidayGroup { grid-column: 2 / span 2; }
        .range-group {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
        }
        .range-group input[type="datetime-local"] {
            flex: 1 1 0;
            min-width: 0; /* prevent overflow */
        }
        .range-group span {
            white-space: nowrap;
            color: #666;
        }

        label {
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
        }

        input, select, textarea {
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .part-input-container {
            position: relative;
        }

        .part-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e1e8ed;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .suggestion-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .suggestion-item:hover {
            background: #f8f9fa;
        }

        .chips-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .chip {
            background: #667eea;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip-remove {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chip-remove:hover {
            background: rgba(255,255,255,0.2);
        }

        .priority-group {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .priority-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .priority-option input[type="radio"] {
            width: auto;
            margin: 0;
        }

        .tab-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 0;
        }

        .tab-btn {
            padding: 12px 24px;
            border: none;
            background: #f8f9fa;
            color: #666;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tab-btn.active {
            background: #667eea;
            color: white;
        }

        .tab-btn:hover:not(.active) {
            background: #e9ecef;
        }

        .tab-content {
            margin-top: -25px;
        }

        small {
            color: #888;
            font-size: 12px;
            margin-top: 2px;
            display: block;
        }

        .advanced-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 14px;
            text-decoration: underline;
            margin-bottom: 15px;
        }

        .advanced-options {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .advanced-options.show {
            display: grid;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .priority-low { background: #6c757d; }
        .priority-urgent { background: #dc3545; }
        .priority-high { background: #fd7e14; }
        .priority-normal { background: #28a745; }

        .collapsible-header {
            cursor: pointer;
            user-select: none;
            margin: 20px 0 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        .collapsible-header:hover {
            background: #e9ecef;
        }

        .collapsible-header span {
            display: inline-block;
            transition: transform 0.3s ease;
            margin-right: 8px;
        }

        .optional-overrides-section {
            margin-top: 20px;
        }

        .operation-checkboxes {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background: #f8f9fa;
        }

        .operation-checkbox-item {
            display: inline-block;
            margin: 5px 10px 5px 0;
        }

        .operation-checkbox-item input[type="checkbox"] {
            margin-right: 5px;
        }

        .operation-checkbox-item label {
            font-weight: normal;
            cursor: pointer;
        }

        .operation-dropdown-container {
            position: relative;
        }

        .operation-selector {
            display: flex;
            position: relative;
        }

        .operation-selector input {
            flex: 1;
            border-radius: 5px 0 0 5px;
            border-right: none;
        }

        .operation-btn {
            background: #007bff;
            color: white;
            border: 1px solid #007bff;
            border-radius: 0 5px 5px 0;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .operation-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .operation-btn:disabled {
            background: #6c757d;
            border-color: #6c757d;
            cursor: not-allowed;
        }

        .operation-btn.open {
            transform: rotate(180deg);
        }

        .operation-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            max-height: 250px;
            overflow-y: auto;
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .operation-dropdown-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-bottom: 1px solid #f1f3f4;
        }

        .operation-dropdown-item:last-child {
            border-bottom: none;
        }

        .operation-dropdown-item:hover {
            background-color: #f8f9fa;
        }

        .operation-dropdown-item input[type="checkbox"] {
            margin-right: 10px;
        }

        .operation-dropdown-item label {
            flex: 1;
            cursor: pointer;
            font-weight: normal;
        }

        .operation-dropdown-footer {
            padding: 10px 15px;
            border-top: 1px solid #dee2e6;
            background: #f8f9fa;
            display: flex;
            justify-content: space-between;
        }

        .operation-dropdown-footer button {
            padding: 5px 15px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-clear {
            background: #6c757d;
            color: white;
        }

        .btn-apply {
            background: #28a745;
            color: white;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        /* Enhanced Schedule Results Table Styles */
        #resultsTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #resultsTable th {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            font-size: 14px;
        }

        #resultsTable td {
            padding: 12px 10px;
            border-bottom: 1px solid #ecf0f1;
            font-size: 13px;
        }

        #resultsTable tr:hover {
            background-color: #f8f9fa;
        }

        #resultsTable tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .status-success {
            color: #27ae60;
            font-weight: bold;
        }

        .status-warning {
            color: #f39c12;
            font-weight: bold;
        }

        .status-danger {
            color: #e74c3c;
            font-weight: bold;
        }

        /* Priority-based table row colors */
        #resultsTable tr.priority-urgent {
            background-color: #ffebee !important;
            border-left: 4px solid #e74c3c;
        }

        #resultsTable tr.priority-urgent:hover {
            background-color: #ffcdd2 !important;
        }

        #resultsTable tr.priority-high {
            background-color: #fff3e0 !important;
            border-left: 4px solid #f39c12;
        }

        #resultsTable tr.priority-high:hover {
            background-color: #ffe0b2 !important;
        }

        #resultsTable tr.priority-normal {
            background-color: #e8f5e8 !important;
            border-left: 4px solid #27ae60;
        }

        #resultsTable tr.priority-normal:hover {
            background-color: #c8e6c9 !important;
        }

        #resultsTable tr.priority-low {
            background-color: #f5f5f5 !important;
            border-left: 4px solid #95a5a6;
        }

        #resultsTable tr.priority-low:hover {
            background-color: #e0e0e0 !important;
        }

        .nowrap {
            white-space: nowrap;
            word-break: keep-all;
        }

        /* Advanced Settings Enhanced Styles */
        .card h4 {
            color: #34495e;
            margin-bottom: 15px;
            font-size: 1em;
            font-weight: 600;
        }

        /* Advanced Settings layout grids */
        .advanced-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            align-items: start;
        }

        .advanced-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .shifts-container {
            margin-top: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .shifts-container .form-group {
            margin-bottom: 10px;
        }

        .shifts-container .form-group:last-child {
            margin-bottom: 0;
        }

        .holiday-input-section, .breakdown-input-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .holiday-datetime-inputs, .breakdown-datetime-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .datetime-pair {
            display: flex;
            flex-direction: column;
        }

        .datetime-pair label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .machine-checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .holiday-list-section, .breakdown-list-section {
            margin-top: 20px;
        }

        .holiday-table, .breakdown-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .holiday-table th, .breakdown-table th {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            padding: 12px 10px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
        }

        .holiday-table td, .breakdown-table td {
            padding: 10px;
            border-bottom: 1px solid #ecf0f1;
            font-size: 12px;
        }

        .holiday-table tr:hover, .breakdown-table tr:hover {
            background-color: #f8f9fa;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        /* Part Selection & Order Management Enhanced Styles */
        .card h3 {
            color: #34495e;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .priority-group {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .priority-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .priority-option input[type="radio"] {
            width: auto;
            margin: 0;
        }

        .three-way-toggle {
            display: flex !important;
            background: #e9ecef;
            border-radius: 25px;
            padding: 4px;
            position: relative;
            overflow: hidden;
            width: 100%;
            max-width: 600px;
            height: 50px;
            visibility: visible !important;
            opacity: 1 !important;
            border: 2px solid #dee2e6;
            transition: all 0.3s ease;
        }
        
        .three-way-toggle:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }
        
        .toggle-option {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 20px;
            position: relative;
            z-index: 1;
            font-size: 0.85rem;
            min-height: 40px;
            margin: 2px;
            user-select: none;
            min-width: 0;
        }
        
        /* Base colors for each mode - all white by default */
        .toggle-option[data-mode="single-batch"] {
            background: white; /* White background */
            color: #666; /* Neutral text color */
        }
        
        .toggle-option[data-mode="auto-split"] {
            background: white; /* White background */
            color: #666; /* Neutral text color */
        }
        
        .toggle-option[data-mode="custom-batch-size"] {
            background: white; /* White background */
            color: #666; /* Neutral text color */
        }
        
        .toggle-option.active {
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transform: scale(1.02);
        }
        
        /* Color coding for different modes - more specific to override base white */
        .toggle-option[data-mode="single-batch"].active {
            background: #28a745 !important; /* Green for Single Batch */
            color: white !important;
        }
        
        .toggle-option[data-mode="auto-split"].active {
            background: #dc3545 !important; /* Red for Auto-Split */
            color: white !important;
        }
        
        .toggle-option[data-mode="custom-batch-size"].active {
            background: #ffc107 !important; /* Yellow for Custom Size */
            color: #212529 !important; /* Dark text for better contrast on yellow */
        }
        
        /* Priority toggle colors - specific to priorityToggle */
        #priorityToggle .toggle-option[data-mode="urgent"] {
            background: white; /* White background */
            color: #666; /* Neutral text color */
        }
        
        #priorityToggle .toggle-option[data-mode="high"] {
            background: white; /* White background */
            color: #666; /* Neutral text color */
        }
        
        #priorityToggle .toggle-option[data-mode="normal"] {
            background: white; /* White background */
            color: #666; /* Neutral text color */
        }
        
        #priorityToggle .toggle-option[data-mode="low"] {
            background: white; /* White background */
            color: #666; /* Neutral text color */
        }
        
        #priorityToggle .toggle-option[data-mode="urgent"].active {
            background: #dc3545 !important; /* Red for Urgent */
            color: white !important;
        }
        
        #priorityToggle .toggle-option[data-mode="high"].active {
            background: #fd7e14 !important; /* Orange for High */
            color: white !important;
        }
        
        #priorityToggle .toggle-option[data-mode="normal"].active {
            background: #28a745 !important; /* Green for Normal */
            color: white !important;
        }
        
        #priorityToggle .toggle-option[data-mode="low"].active {
            background: #90ee90 !important; /* Light green for Low */
            color: #212529 !important; /* Dark text for contrast */
        }
        
        .toggle-option:hover:not(.active) {
            background: #dee2e6;
            transform: scale(1.01);
        }
        
        /* Hover effects - subtle gray */
        .toggle-option[data-mode="single-batch"]:hover:not(.active) {
            background: #f8f9fa; /* Light gray hover */
        }
        
        .toggle-option[data-mode="auto-split"]:hover:not(.active) {
            background: #f8f9fa; /* Light gray hover */
        }
        
        .toggle-option[data-mode="custom-batch-size"]:hover:not(.active) {
            background: #f8f9fa; /* Light gray hover */
        }
        
        .toggle-icon {
            margin-right: 4px;
            font-size: 0.9rem;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .toggle-text {
            font-size: 0.8rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            text-align: center;
        }
        
        /* Priority toggle text specific styling */
        #priorityToggle .toggle-text {
            font-size: 0.8rem;
            font-weight: 600;
            color: #666 !important; /* Ensure text is visible */
            white-space: nowrap;
            overflow: visible; /* Allow text to be fully visible */
            text-overflow: unset; /* Remove ellipsis truncation */
            flex: 1;
            text-align: center;
            min-width: 0; /* Allow text to shrink if needed */
        }
        
        #priorityToggle .toggle-option.active .toggle-text {
            color: white !important; /* White text on colored backgrounds */
        }
        
        #priorityToggle .toggle-option[data-mode="low"].active .toggle-text {
            color: #212529 !important; /* Dark text on light green background */
        }
        
        /* Priority toggle container specific styling */
        #priorityToggle {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            height: 50px !important;
            max-width: 700px !important; /* Increased from 600px */
            width: 100% !important;
        }
        
        #priorityToggle .toggle-option {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            min-height: 40px !important;
            padding: 10px 12px !important; /* Increased horizontal padding */
            margin: 2px !important;
            min-width: 0 !important; /* Allow options to shrink if needed */
            flex: 1 !important; /* Equal distribution of space */
        }
        
        #customBatchSize {
            width: 70px !important;
            padding: 4px !important;
            border: 1px solid #ddd !important;
            border-radius: 4px !important;
            background: #ffc107 !important; /* Yellow background to match active state */
            color: #212529 !important; /* Dark text for contrast */
            margin: 0 2px !important;
            font-size: 0.8rem !important;
            flex-shrink: 0;
        }

        .part-input-container {
            position: relative;
        }

        .part-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e1e8ed;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .suggestion-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
        }

        .suggestion-item:hover {
            background-color: #f8f9fa;
        }

        .operation-dropdown-container {
            position: relative;
        }

        .operation-selector {
            display: flex;
            align-items: center;
        }

        .operation-selector input {
            flex: 1;
            border-radius: 8px 0 0 8px;
        }

        .operation-btn {
            padding: 12px 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .operation-btn:hover {
            background: #5a6fd8;
        }

        .operation-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .operation-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e1e8ed;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
        }

        .operation-option {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
        }

        .operation-option:hover {
            background-color: #f8f9fa;
        }

        .optional-overrides-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e1e8ed;
        }

        .collapsible-header {
            cursor: pointer;
            padding: 10px 0;
            color: #667eea;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .collapsible-header:hover {
            color: #5a6fd8;
        }

        .form-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e1e8ed;
        }

        /* Saved Orders Management Enhanced Styles */
        .saved-orders-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .priority-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .priority-urgent {
            background: #ffebee;
            color: #c62828;
        }

        .priority-high {
            background: #fff3e0;
            color: #ef6c00;
        }

        .priority-normal {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .priority-low {
            background: #f5f5f5;
            color: #616161;
        }

        .batch-mode-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
        }

        .batch-mode-auto-split {
            background: #ffebee;
            color: #c62828;
        }

        .batch-mode-single-batch {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .batch-mode-custom {
            background: #fff3e0;
            color: #ef6c00;
        }

        .action-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        /* Light colored action buttons for Saved Orders */
        .action-buttons .btn {
            border: 1px solid #dee2e6 !important;
            padding: 6px 10px !important;
            font-size: 12px !important;
            border-radius: 4px !important;
            transition: all 0.2s ease !important;
            box-shadow: none !important;
        }
        
        .action-buttons .btn-primary {
            background: rgba(102, 126, 234, 0.2) !important; /* Light blue-purple */
            color: #667eea !important;
        }
        
        .action-buttons .btn-primary:hover {
            background: rgba(102, 126, 234, 0.3) !important;
            color: #5a6fd8 !important;
        }
        
        .action-buttons .btn-warning {
            background: rgba(255, 193, 7, 0.2) !important; /* Light yellow */
            color: #ffc107 !important;
        }
        
        .action-buttons .btn-warning:hover {
            background: rgba(255, 193, 7, 0.3) !important;
            color: #e0a800 !important;
        }
        
        .action-buttons .btn-info {
            background: rgba(23, 162, 184, 0.2) !important; /* Light teal-blue */
            color: #17a2b8 !important;
        }
        
        .action-buttons .btn-info:hover {
            background: rgba(23, 162, 184, 0.3) !important;
            color: #138496 !important;
        }
        
        .action-buttons .btn-danger {
            background: rgba(231, 76, 60, 0.2) !important; /* Light red */
            color: #e74c3c !important;
        }
        
        .action-buttons .btn-danger:hover {
            background: rgba(231, 76, 60, 0.3) !important;
            color: #c0392b !important;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-info:hover {
            background: #138496;
        }

        .empty-state {
            text-align: center;
            color: #888;
            padding: 40px 20px;
            font-style: italic;
        }

        /* Alert styles for notifications */
        .alert {
            padding: 12px 16px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: 500;
        }

        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e1e8ed;
        }

        /* Prevent wrapping in specific table cells (dates, times, timing text) */
        .nowrap {
            white-space: nowrap;
            word-break: keep-all;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .action-bar {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 20px;
            border-top: 2px solid #e1e8ed;
            display: flex;
            gap: 15px;
            justify-content: center;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            margin: 20px -20px -20px -20px;
            border-radius: 0 0 12px 12px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .action-bar {
                flex-direction: column;
            }
            
            .priority-group {
                flex-direction: column;
                gap: 10px;
            }
        }

        /* Sync Controls Styling */
        .sync-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-secondary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .sync-status {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 12px;
        }

        .sync-status small {
            color: #6b7280;
            margin-top: 2px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spinning {
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div id="loadingOverlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; color: white; font-size: 1.5rem;">
        Loading...
    </div>

    <div class="container">
        <div class="card">
            <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                <h2>Production Schedule Generator</h2>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <div id="userRoleIndicator" style="padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold;"></div>
                    <button class="btn btn-danger" onclick="logout()">Logout</button>
                </div>
            </div>
            <div class="header">
                <h1>🏭 Production Scheduler</h1>
                <p>Advanced Manufacturing Scheduling System</p>
            </div>

        <!-- Tab Navigation -->
        <div class="card">
            <div class="tab-nav">
                <button class="tab-btn active" onclick="switchTab('orders')">📋 Orders</button>
                <button class="tab-btn" onclick="switchTab('advanced')">⚙️ Advanced Settings</button>
            </div>
        </div>

        <!-- Orders Tab -->
        <div class="card tab-content" id="ordersTab">
            <h2>📝 Order Management</h2>
            <form id="orderForm">
                <h3>Mandatory Fields</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="partNumber">Part Number</label>
                        <div class="part-input-container">
                            <input type="text" id="partNumber" placeholder="Search part numbers..." required>
                            <div class="part-suggestions" id="partSuggestions"></div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="operationSeq">Operation Sequence</label>
                        <div class="operation-dropdown-container">
                            <div class="operation-selector">
                                <input type="text" id="operationSeqDisplay" placeholder="Select a part number first" readonly disabled>
                                <button type="button" id="operationSeqBtn" class="operation-btn" onclick="toggleOperationDropdown()" disabled>
                                    <span>▼</span>
                                </button>
                            </div>
                            <div id="operationDropdown" class="operation-dropdown" style="display: none;">
                                <!-- Dynamic operation options will be populated here -->
                            </div>
                        </div>
                        <input type="hidden" id="operationSeq" value="">
                    </div>

                    <div class="form-group">
                        <label>Priority</label>
                        <div class="three-way-toggle" id="priorityToggle">
                            <div class="toggle-option" data-mode="urgent">
                                <span class="toggle-icon">🔴</span>
                                <span class="toggle-text">Urgent</span>
                            </div>
                            <div class="toggle-option" data-mode="high">
                                <span class="toggle-icon">🟠</span>
                                <span class="toggle-text">High</span>
                            </div>
                            <div class="toggle-option active" data-mode="normal">
                                <span class="toggle-icon">🟡</span>
                                <span class="toggle-text">Normal</span>
                            </div>
                            <div class="toggle-option" data-mode="low">
                                <span class="toggle-icon">🟢</span>
                                <span class="toggle-text">Low</span>
                            </div>
                        </div>
                        <!-- Hidden radio inputs for form submission -->
                        <input type="radio" id="priorityUrgent" name="priority" value="Urgent" style="display: none;">
                        <input type="radio" id="priorityHigh" name="priority" value="High" style="display: none;">
                        <input type="radio" id="priorityNormal" name="priority" value="Normal" checked style="display: none;">
                        <input type="radio" id="priorityLow" name="priority" value="Low" style="display: none;">
                    </div>

                    <div class="form-group">
                        <label for="dueDate">Due Date</label>
                        <input type="date" id="dueDate">
                        <small style="color: #666; font-size: 0.8rem;">Optional - Leave blank for no due date constraint</small>
                    </div>

                    <div class="form-group">
                        <label for="orderQuantity">Order Quantity</label>
                        <input type="number" id="orderQuantity" min="1" required>
                    </div>

                    <div class="form-group">
                        <label>Batch Mode Switch</label>
                        <div class="three-way-toggle">
                            <div class="toggle-option" data-mode="single-batch">
                                <span class="toggle-icon">◀</span>
                                <span class="toggle-text">Single</span>
                            </div>
                            
                            <div class="toggle-option" data-mode="auto-split">
                                <span class="toggle-icon">⭕</span>
                                <span class="toggle-text">Auto-Split</span>
                            </div>
                            
                            <div class="toggle-option" data-mode="custom-batch-size">
                                <span class="toggle-text" id="customSizeText">Custom</span>
                                <input type="number" id="customBatchSize" min="1" placeholder="Size" style="width: 100px; padding: 4px; border: 1px solid #ddd; border-radius: 4px; display: none; background: white; margin: 0;">
                                <span class="toggle-icon">▶</span>
                            </div>
                        </div>
                        
                        <!-- Hidden radio inputs for form submission -->
                        <input type="radio" name="batchMode" value="single-batch" id="batchModeSingle" style="display: none;">
                        <input type="radio" name="batchMode" value="auto-split" id="batchModeAuto" checked style="display: none;">
                        <input type="radio" name="batchMode" value="custom-batch-size" id="batchModeCustom" style="display: none;">
                    </div>
                </div>

                <div class="optional-overrides-section">
                    <h3 class="collapsible-header" onclick="toggleOptionalOverrides()">
                        <span id="overrideToggleIcon">▶</span> Optional Overrides 
                        <small>(Click to expand advanced settings for this order)</small>
                    </h3>
                    <div class="form-grid" id="optionalOverridesContent" style="display: none;">
                        <div class="form-group">
                            <label for="orderBreakdownMachine">Breakdown Machine</label>
                            <select id="orderBreakdownMachine">
                                <option value="">Use Global Setting</option>
                                <option value="VMC 1">VMC 1</option>
                                <option value="VMC 2">VMC 2</option>
                                <option value="VMC 3">VMC 3</option>
                                <option value="VMC 4">VMC 4</option>
                                <option value="VMC 5">VMC 5</option>
                                <option value="VMC 6">VMC 6</option>
                                <option value="VMC 7">VMC 7</option>
                            </select>
                        </div>

                        <div class="form-group" id="orderBreakdownGroup">
                            <label for="orderBreakdownStart">Breakdown Date-Time Range</label>
                            <div class="range-group">
                                <input type="datetime-local" id="orderBreakdownStart">
                                <span>to</span>
                                <input type="datetime-local" id="orderBreakdownEnd">
                            </div>
                            <small>Choose a start and end. The machine will rest during this range.</small>
                        </div>

                        <div class="form-group">
                            <label for="orderStartDateTime">Order Start Date & Time (Per Order Rule)</label>
                            <input type="datetime-local" id="orderStartDateTime" placeholder="mm/dd/yyyy, --:-- --">
                            <small>📅 Please select the Start Date & Time for this order.<br>
                            ⚠️ This sets the earliest allowed start time for setup/processing of this order. The scheduler must not schedule this order before the chosen time — even if machines are free.<br>
                            <strong>Behavior rule:</strong> If Order Start Date-Time is defined → compare with Global Start Date-Time → actual order start = max(GlobalStart, OrderStart). If not defined → order is eligible immediately from Global Start Date-Time.<br>
                            <strong>Example:</strong> Global Start Date-Time = 2025-09-10 03:00, Order Start Date-Time = 2025-09-10 06:00 → This order must wait until 06:00 to begin setup, even though global clock starts at 03:00.</small>
                        </div>

                        <div class="form-group" id="orderHolidayGroup">
                            <label for="orderHolidayStart">Holiday</label>
                            <div class="range-group">
                                <input type="datetime-local" id="orderHolidayStart">
                                <span>to</span>
                                <input type="datetime-local" id="orderHolidayEnd">
                            </div>
                            <small>Choose a start and end. Time between will be treated as holiday for this order.</small>
                        </div>

                        <div class="form-group">
                            <label for="orderSetupWindow">Setup Availability Window</label>
                            <input type="text" id="orderSetupWindow" placeholder="08:00-18:00">
                            <small>Format: HH:MM-HH:MM</small>
                        </div>
                    </div>
                </div>

                <div class="form-actions">
                    <button id="orderSubmitBtn" type="submit" class="btn btn-primary">➕ Add Order</button>
                    <button type="button" class="btn btn-secondary" onclick="clearForm()">🗑️ Clear Form</button>
                    <button id="editOrderBtn" type="button" class="btn btn-success" style="display:none;" onclick="updateOrder()">💾 Update Order</button>
                    <button id="cancelEditBtn" type="button" class="btn btn-secondary" style="display:none;" onclick="cancelEdit()">✖️ Cancel</button>
                </div>
            </form>
        </div>

        <!-- Advanced Settings Tab -->
        <div class="card tab-content" id="advancedTab" style="display: none;">
            <h2>⚙️ Global Advanced Settings</h2>
            <div class="advanced-grid-3">
                <div class="form-group">
                    <label for="startDateTime">Global Start Date & Time (Master Clock)</label>
                    <input type="datetime-local" id="startDateTime" placeholder="mm/dd/yyyy, --:-- --">
                </div>

                <!-- Global Setup Window (People-Dependent) -->
                <div class="form-group">
                    <label for="setupAvailabilityWindow">Global Setup Window (People-Dependent)</label>
                    <input type="text" id="setupAvailabilityWindow" value="06:00-22:00" placeholder="06:00-22:00">
                    <small>Format: HH:MM-HH:MM. Auto-filled from Shift 1 and Shift 2 below (earliest start to latest end). You can still override manually.</small>
                    <div class="shifts-container">
                        <div class="form-group">
                            <label for="shift1">Shift 1 (Controls Global Setup Window)</label>
                            <input type="text" id="shift1" value="06:00-14:00" placeholder="06:00-14:00">
                </div>
                <div class="form-group">
                            <label for="shift2">Shift 2 (Controls Global Setup Window)</label>
                            <input type="text" id="shift2" value="14:00-22:00" placeholder="14:00-22:00">
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Production Window (Machine-Dependent)</label>
                    <div class="shifts-container">
                        <div class="form-group">
                            <label for="prodShift1">Shift 1 (Morning)</label>
                            <input type="text" id="prodShift1" value="06:00-14:00" placeholder="06:00-14:00">
                </div>
                <div class="form-group">
                            <label for="prodShift2">Shift 2 (Afternoon)</label>
                            <input type="text" id="prodShift2" value="14:00-22:00" placeholder="14:00-22:00">
                </div>
                <div class="form-group">
                            <label for="prodShift3">Shift 3 (Night)</label>
                            <input type="text" id="prodShift3" value="22:00-06:00" placeholder="22:00-06:00">
                </div>
                    </div>
                </div>
            </div><!-- /.advanced-grid-3 -->

            <div class="advanced-grid-2">
                <div class="form-group">
                    <label for="holidays">Holiday Calendar (Global Pauses)</label>
                    <div class="holiday-input-section">
                        <div class="holiday-datetime-inputs">
                            <div class="datetime-pair">
                                <label for="holidayStart">Start DateTime:</label>
                                <input type="datetime-local" id="holidayStart" placeholder="Start date and time">
                            </div>
                            <div class="datetime-pair">
                                <label for="holidayEnd">End DateTime:</label>
                                <input type="datetime-local" id="holidayEnd" placeholder="End date and time">
                            </div>
                            <div class="datetime-pair">
                                <label for="holidayReason">Reason (Optional):</label>
                                <input type="text" id="holidayReason" placeholder="e.g., National Holiday, Maintenance">
                            </div>
                        </div>
                        <button type="button" class="btn btn-primary" onclick="addHoliday()">➕ Add Holiday</button>
                </div>

                    <!-- Holiday List Display -->
                    <div class="holiday-list-section">
                        <h4>📅 Saved Holidays</h4>
                        <div class="holiday-list-container" id="holidayListContainer">
                            <table class="holiday-table" id="holidayTable">
                                <thead>
                                    <tr>
                                        <th>Start DateTime</th>
                                        <th>End DateTime</th>
                                        <th>Type</th>
                                        <th>Reason</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="holidayTableBody">
                                    <tr>
                                        <td colspan="5" style="text-align: center; color: #888;">No holidays added yet</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="breakdownMachines">Machine Breakdowns (Downtime Control)</label>
                    <div class="breakdown-input-section">
                        <div class="breakdown-machine-selection">
                            <label for="breakdownMachineSelect">Select Machines:</label>
                            <div class="machine-checkbox-group" id="machineCheckboxGroup">
                                <label class="checkbox-item"><input type="checkbox" value="VMC 1"> VMC 1</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 2"> VMC 2</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 3"> VMC 3</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 4"> VMC 4</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 5"> VMC 5</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 6"> VMC 6</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 7"> VMC 7</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 8"> VMC 8</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 9"> VMC 9</label>
                                <label class="checkbox-item"><input type="checkbox" value="VMC 10"> VMC 10</label>
                            </div>
                        </div>
                        
                        <div class="breakdown-datetime-inputs">
                            <div class="datetime-pair">
                                <label for="breakdownStart">Start DateTime:</label>
                                <input type="datetime-local" id="breakdownStart" placeholder="Start date and time" required>
                            </div>
                            <div class="datetime-pair">
                                <label for="breakdownEnd">End DateTime:</label>
                                <input type="datetime-local" id="breakdownEnd" placeholder="End date and time" required>
                            </div>
                            <div class="datetime-pair">
                                <label for="breakdownReason">Reason (Optional):</label>
                                <input type="text" id="breakdownReason" placeholder="e.g., Power Maintenance, Coolant Pump Failure">
                            </div>
                        </div>
                        <button type="button" class="btn btn-primary" onclick="addBreakdown()">🔧 Add Breakdown</button>
                    </div>
                    
                    <!-- Breakdown List Display -->
                    <div class="breakdown-list-section">
                        <h4>🔧 Saved Machine Breakdowns</h4>
                        <div class="breakdown-list-container">
                            <table class="breakdown-table" id="breakdownTable">
                                <thead>
                                    <tr>
                                        <th>Machines</th>
                                        <th>Start DateTime</th>
                                        <th>End DateTime</th>
                                        <th>Reason</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="breakdownTableBody">
                                    <tr>
                                        <td colspan="5" style="text-align: center; color: #888;">No breakdowns added yet</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <button type="button" class="btn btn-secondary" onclick="saveAdvancedSettings()">💾 Save Settings</button>
        </div>

        <!-- Saved Orders Table -->
        <div class="card">
            <div class="saved-orders-header">
            <h2>📋 Saved Orders</h2>
                <div>
                    <button id="clearAllOrdersBtn" class="btn btn-danger" onclick="clearAllSavedOrders()">
                        All Clear ❌
                    </button>
                </div>
            </div>
            <div class="table-container">
                <table id="ordersTable">
                    <thead>
                        <tr>
                            <th>Part Number</th>
                            <th>Operation Seq</th>
                            <th>Order Quantity</th>
                            <th>Priority</th>
                            <th>Due Date</th>
                            <th>Batch Mode</th>
                            <th>Breakdown Machine</th>
                            <th>Breakdown DateTime</th>
                            <th>Start DateTime</th>
                            <th>Holiday</th>
                            <th>Setup Window</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="ordersTableBody">
                        <tr>
                            <td colspan="12" class="empty-state">No orders added yet</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Schedule Results -->
        <div class="card" id="resultsCard" style="display: none;">
            <h2>📊 Schedule Results</h2>
            <div id="scheduleAlerts"></div>
            <div class="table-container">
                <table id="resultsTable">
                    <thead>
                        <tr>
                            <th>Part Number</th>
                            <th>Order Qty</th>
                            <th>Priority</th>
                            <th>Batch ID</th>
                            <th>Batch Qty</th>
                            <th>Operation Seq</th>
                            <th>Operation Name</th>
                            <th>Machine</th>
                            <th>Person</th>
                            <th>Setup Start</th>
                            <th>Setup End</th>
                            <th>Run Start</th>
                            <th>Run End</th>
                            <th>Timing</th>
                            <th>Due Date</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody"></tbody>
                </table>
            </div>
        </div>

        <!-- Loading Indicator -->
        <div class="loading" id="loadingIndicator">
            <div class="spinner"></div>
            <p>Processing schedule...</p>
        </div>

        <!-- Action Bar -->
        <div class="action-bar">
            <button class="btn btn-success" onclick="runSchedule()">
                ▶️ Run Schedule
            </button>
            <button class="btn btn-info" onclick="importFromExcel()" id="importBtn">
                ⬆️ Import Excel
            </button>
            <button class="btn btn-secondary" onclick="exportToExcel()" id="exportBtn" disabled>
                ⬇️ Export Excel
            </button>
            <button class="btn btn-warning" onclick="clearSession()" id="clearBtn">
                🔄 Clear
            </button>
        </div>
    </div>


    <!-- Add Supabase client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Initialize Supabase first -->
    <script>
        // Create a global Supabase client initialization function
        function initSupabase() {
            const SUPABASE_URL = 'https://sxnaopzgaddvziplrlbe.supabase.co';
            const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN4bmFvcHpnYWRkdnppcGxybGJlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY2MjUyODQsImV4cCI6MjA3MjIwMTI4NH0.o3UAaJtrNpVh_AsljSC1oZNkJPvQomedvtJlXTE3L6w';
            
            // Initialize and return the Supabase client
            return supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
                auth: {
                    autoRefreshToken: true,
                    persistSession: true,
                    detectSessionInUrl: false, // Disable URL session detection to prevent redirect loops
                    storage: window.localStorage
                }
            });
        }
        
        // Initialize Supabase immediately
        try {
            const supabase = initSupabase();
            window.supabase = supabase; // Make available globally
            console.log('Supabase initialized successfully');
            
            // Check for session in URL hash and clear it to prevent redirect loops
            if (window.location.hash) {
                const hash = window.location.hash;
                if (hash.includes('access_token') || hash.includes('error=')) {
                    // Clear the hash without refreshing
                    history.replaceState(null, null, ' ');
                }
            }
        } catch (error) {
            console.error('Failed to initialize Supabase:', error);
            // Show error to user
            const errorElement = document.createElement('div');
            errorElement.style.color = 'red';
            errorElement.style.padding = '20px';
            errorElement.style.textAlign = 'center';
            errorElement.textContent = 'Failed to initialize the application. Please refresh the page or contact support.';
            document.body.prepend(errorElement);
        }
    </script>
    
    <!-- Load other scripts -->
    <script src="app.js"></script>
    <script src="data.js"></script>
    <script src="x10-browser.js"></script>
    
    <script>
        // Initialize the app after checking authentication
        async function initializeApp() {
            try {
                // Wait for Supabase to be fully initialized
                if (!window.supabase) {
                    console.error('Supabase client not initialized');
                    throw new Error('Authentication service not available');
                }
                
                // Check authentication
                const { data: { session }, error } = await window.supabase.auth.getSession();
                
                if (error) {
                    console.error('Error getting session:', error);
                    window.location.href = 'auth.html';
                    return;
                }
                
                if (!session) {
                    console.log('No active session, redirecting to login');
                    // Clear any existing session data
                    await window.supabase.auth.signOut();
                    window.location.href = 'auth.html';
                    return;
                }
                
                console.log('User authenticated, proceeding to app');

                // Hide loading overlay when app is initialized
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
                
                // Initialize your existing app
                // Check if we have persisted data
                if (window.OP_MASTER && window.OP_MASTER.length > 0) {
                    // Update UI with existing data
                    updateOrdersTable();
                }
                
                // Set default due date
                setDefaultDueDate();
            } catch (error) {
                console.error('Initialization error:', error);
                window.location.href = 'auth.html';
            }
        }

        // Start the app initialization
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>

    <script>
        // Global variables
        let savedOrders = [];
        let scheduleResults = [];
        let selectedPartNumber = '';
        let editingOrderId = null; // when not null, form is in edit mode
        let advancedSettings = {
            startDateTime: null,
            setupAvailabilityWindow: '06:00-22:00',
            breakdownMachines: [],
            breakdownDateTime: '',
            holidays: [],
            breakdowns: [],
            shift1: '06:00-14:00',
            shift2: '14:00-22:00',
            shift3: '22:00-06:00'
        };

        // Helper: get unique part numbers from the current operations master data
        function getAvailablePartNumbers() {
            try {
                return [...new Set((window.OP_MASTER || []).map(op => String(op.PartNumber).trim()))].sort();
            } catch (e) {
                console.warn('Failed to compute available part numbers:', e);
                return [];
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeForUserRole();
            setupFormSubmission();
            setupBatchModeToggle();
            setupPriorityToggle();
            initializeAdvancedSettings();
            setDefaultDueDate();
            setupDueDateField();
            updateUserRoleIndicator();
            loadAdvancedSettings(); // Load saved advanced settings
        });

        // Initialize based on user role
        async function initializeForUserRole() {
            try {
                const userRole = await getCurrentUserRole();
                
                if (userRole === 'Test User') {
                    // Clear all database data for test users
                    window.OP_MASTER = [];
                    testUserData = null;
                    isUsingTestData = false;
                    
                    // Setup empty part number search
                    setupEmptyPartNumberSearch();
                } else {
                    // Normal initialization for Admin/Operator
                    setupPartNumberSearch();
                }
            } catch (error) {
                console.error('Error initializing for user role:', error);
                // Fallback to normal initialization
                setupPartNumberSearch();
            }
        }

        // Setup empty part number search for Test Users
        function setupEmptyPartNumberSearch() {
            const partNumberInput = document.getElementById('partNumber');
            const partNumberResults = document.getElementById('partNumberResults');
            
            if (partNumberInput) {
                partNumberInput.placeholder = 'Import Excel file first to see part numbers';
                partNumberInput.disabled = true;
            }
            
            if (partNumberResults) {
                partNumberResults.innerHTML = '<div style="padding: 10px; color: #888; font-style: italic;">No part numbers available. Please import Excel file first.</div>';
                partNumberResults.style.display = 'block';
            }
            
            // Override getAvailablePartNumbers to return empty array
            window.getAvailablePartNumbers = function() {
                return [];
            };
        }

        function initializeAdvancedSettings() {
            // Set default values
            const now = new Date();
            now.setHours(6, 0, 0, 0);
            document.getElementById('startDateTime').value = now.toISOString().slice(0, 16);
            
            // Add event listeners for auto-update setup window
            document.getElementById('shift1').addEventListener('input', updateSetupWindow);
            document.getElementById('shift2').addEventListener('input', updateSetupWindow);
            
            // Initialize tables
            updateHolidayTable();
            updateBreakdownTable();
        }

        function setDefaultDueDate() {
            const oneWeekFromNow = new Date();
            oneWeekFromNow.setDate(oneWeekFromNow.getDate() + 7); // One week from now
            document.getElementById('dueDate').value = oneWeekFromNow.toISOString().split('T')[0];
        }

        function setupDueDateField() {
            const dueDateInput = document.getElementById('dueDate');
            
            // Set default value if field is empty
            if (!dueDateInput.value) {
                setDefaultDueDate();
            }
            
            // Add event listener to set default when field becomes empty
            dueDateInput.addEventListener('blur', function() {
                if (!this.value) {
                    setDefaultDueDate();
                }
            });
            
            // Add event listener to set default when field is cleared
            dueDateInput.addEventListener('input', function() {
                if (!this.value) {
                    setDefaultDueDate();
                }
            });
        }

        function setupPartNumberSearch() {
            const partInput = document.getElementById('partNumber');
            const suggestions = document.getElementById('partSuggestions');

            partInput.addEventListener('input', function() {
                const query = this.value.toLowerCase();
                const parts = getAvailablePartNumbers();
                let matches = [];
                if (query.length === 0) {
                    matches = parts.slice(0, 20);
                } else {
                    matches = parts.filter(part => part.toLowerCase().includes(query));
                }

                if (matches.length > 0) {
                    suggestions.innerHTML = matches.map(part => 
                        `<div class="suggestion-item" onclick="selectPartNumber('${part}')">${part}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
            });

            // Show initial list on focus
            partInput.addEventListener('focus', function() {
                const parts = getAvailablePartNumbers();
                const matches = parts.slice(0, 20);
                if (matches.length > 0) {
                    suggestions.innerHTML = matches.map(part => 
                        `<div class="suggestion-item" onclick="selectPartNumber('${part}')">${part}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                }
            });

            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.part-input-container')) {
                    suggestions.style.display = 'none';
                }
            });
        }

        function selectPartNumber(partNumber) {
            selectedPartNumber = partNumber;
            document.getElementById('partNumber').value = partNumber;
            document.getElementById('partSuggestions').style.display = 'none';
            
            // Populate operation sequences for selected part
            populateOperationSequences(partNumber);
        }

        let availableOperations = [];

        function populateOperationSequences(partNumber) {
            const operationSeqDisplay = document.getElementById('operationSeqDisplay');
            const operationSeqBtn = document.getElementById('operationSeqBtn');
            
            // Use test data if available, otherwise use database data
            const dataSource = isUsingTestData ? testUserData : window.OP_MASTER;
            
            // Get all operations for this part number
            availableOperations = dataSource.filter(op => {
                const partNum = op.PartNumber || op.partnumber;
                return partNum === partNumber;
            });
            
            if (availableOperations.length === 0) {
                operationSeqDisplay.placeholder = 'No operations found';
                operationSeqBtn.disabled = true;
                return;
            }
            
            // Sort operations by sequence
            availableOperations.sort((a, b) => (a.OperationSeq || a.operationseq) - (b.OperationSeq || b.operationseq));
            
            // Enable the button and update placeholder
            operationSeqDisplay.placeholder = 'Click to select operations';
            operationSeqDisplay.value = 'All operations';
            operationSeqBtn.disabled = false;
            
            // Set default value
            document.getElementById('operationSeq').value = '';
        }

        function toggleOperationDropdown() {
            if (availableOperations.length === 0) return;
            
            const dropdown = document.getElementById('operationDropdown');
            const btn = document.getElementById('operationSeqBtn');
            
            if (dropdown.style.display === 'none') {
                populateDropdownContent();
                dropdown.style.display = 'block';
                btn.classList.add('open');
            } else {
                dropdown.style.display = 'none';
                btn.classList.remove('open');
            }
        }

        function populateDropdownContent() {
            const dropdown = document.getElementById('operationDropdown');
            
            // Create dropdown content
            let dropdownHTML = `
                <div class="operation-dropdown-item" onclick="toggleDropdownItem(this, '')">
                    <input type="checkbox" id="dropdown_all" value="" ${document.getElementById('operationSeq').value === '' ? 'checked' : ''}>
                    <label><strong>All Operations</strong></label>
                </div>
            `;
            
            availableOperations.forEach(op => {
                const currentValue = document.getElementById('operationSeq').value;
                const opSeq = op.OperationSeq || op.operationseq;
                const opName = op.OperationName || op.operationname;
                const isChecked = currentValue.includes(opSeq.toString());
                
                dropdownHTML += `
                    <div class="operation-dropdown-item" onclick="toggleDropdownItem(this, '${opSeq}')">
                        <input type="checkbox" id="dropdown_op_${opSeq}" value="${opSeq}" ${isChecked ? 'checked' : ''}>
                        <label>Op ${opSeq}: ${opName}</label>
                    </div>
                `;
            });
            
            dropdownHTML += `
                <div class="operation-dropdown-footer">
                    <button type="button" class="btn-clear" onclick="clearAllOperations()">Clear All</button>
                    <button type="button" class="btn-apply" onclick="applyOperationSelection()">OK</button>
                </div>
            `;
            
            dropdown.innerHTML = dropdownHTML;
        }

        function toggleDropdownItem(item, value) {
            const checkbox = item.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;
            
            if (value === '') {
                // All operations selected
                if (checkbox.checked) {
                    // Uncheck all individual operations
                    document.querySelectorAll('#operationDropdown input[type="checkbox"]:not(#dropdown_all)').forEach(cb => {
                        cb.checked = false;
                    });
                }
            } else {
                // Individual operation selected
                if (checkbox.checked) {
                    // Uncheck "All operations"
                    document.getElementById('dropdown_all').checked = false;
                }
            }
        }

        function clearAllOperations() {
            document.querySelectorAll('#operationDropdown input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            document.getElementById('dropdown_all').checked = true;
        }

        function applyOperationSelection() {
            const allCheckbox = document.getElementById('dropdown_all');
            const operationCheckboxes = document.querySelectorAll('#operationDropdown input[type="checkbox"]:not(#dropdown_all):checked');
            
            const operationSeqDisplay = document.getElementById('operationSeqDisplay');
            const operationSeqHidden = document.getElementById('operationSeq');
            
            console.log('Applying operation selection...');
            console.log('All checkbox checked:', allCheckbox?.checked);
            console.log('Selected operation checkboxes:', operationCheckboxes.length);
            
            if (allCheckbox?.checked || operationCheckboxes.length === 0) {
                operationSeqDisplay.value = 'All operations';
                operationSeqHidden.value = '';
                console.log('Set to: All operations');
            } else {
                const selectedOps = Array.from(operationCheckboxes).map(cb => cb.value);
                const selectedNames = selectedOps.map(opSeq => {
                    const op = availableOperations.find(o => o.OperationSeq.toString() === opSeq);
                    return `Op ${opSeq}`;
                });
                
                operationSeqDisplay.value = selectedNames.join(', ');
                operationSeqHidden.value = selectedOps.join(',');
                console.log('Set to specific operations:', selectedOps.join(','));
                console.log('Display value:', selectedNames.join(', '));
            }
            
            // Close dropdown
            document.getElementById('operationDropdown').style.display = 'none';
            document.getElementById('operationSeqBtn').classList.remove('open');
        }

        // Helper: derive operation sequence from current checkbox state
        function deriveOperationSeqFromCheckboxes() {
            const allCheckbox = document.getElementById('dropdown_all');
            const operationCheckboxes = document.querySelectorAll('#operationDropdown input[type="checkbox"]:not(#dropdown_all):checked');
            const operationSeqDisplay = document.getElementById('operationSeqDisplay');
            const operationSeqHidden = document.getElementById('operationSeq');
            if (allCheckbox && allCheckbox.checked) {
                operationSeqDisplay.value = 'All operations';
                operationSeqHidden.value = '';
                return '';
            }
            if (operationCheckboxes && operationCheckboxes.length > 0) {
                const selectedOps = Array.from(operationCheckboxes).map(cb => cb.value);
                operationSeqDisplay.value = selectedOps.map(s => `Op ${s}`).join(', ');
                operationSeqHidden.value = selectedOps.join(',');
                return operationSeqHidden.value;
            }
            // Default to All if nothing selected
            operationSeqDisplay.value = 'All operations';
            operationSeqHidden.value = '';
            return '';
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const container = document.querySelector('.operation-dropdown-container');
            if (container && !container.contains(event.target)) {
                const dropdown = document.getElementById('operationDropdown');
                const btn = document.getElementById('operationSeqBtn');
                dropdown.style.display = 'none';
                btn.classList.remove('open');
            }
        });

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Show/hide tab content
            document.getElementById('ordersTab').style.display = tabName === 'orders' ? 'block' : 'none';
            document.getElementById('advancedTab').style.display = tabName === 'advanced' ? 'block' : 'none';
            
            // Load advanced settings when switching to advanced tab
            if (tabName === 'advanced') {
                loadAdvancedSettings();
            }
        }

        // Global variables for holidays and breakdowns
        let holidays = [];
        let breakdowns = [];
        
        // Make variables globally accessible for ExcelExporter
        window.holidays = holidays;
        window.breakdowns = breakdowns;
        window.advancedSettings = advancedSettings;

        function addHoliday() {
            const start = document.getElementById('holidayStart').value;
            const end = document.getElementById('holidayEnd').value;
            const reason = document.getElementById('holidayReason').value;

            if (!start || !end) {
                alert('Please select both start and end date/time for the holiday.');
                return;
            }

            if (new Date(start) >= new Date(end)) {
                alert('End date/time must be after start date/time.');
                return;
            }

            const holiday = {
                id: Date.now(),
                start: start,
                end: end,
                reason: reason || 'Holiday',
                type: 'Holiday'
            };

            holidays.push(holiday);
            window.holidays = holidays; // Update global reference
            updateHolidayTable();
            clearHolidayInputs();
        }

        function addBreakdown() {
            const start = document.getElementById('breakdownStart').value;
            const end = document.getElementById('breakdownEnd').value;
            const reason = document.getElementById('breakdownReason').value;
            const selectedMachines = Array.from(document.querySelectorAll('#machineCheckboxGroup input:checked')).map(cb => cb.value);

            if (!start || !end) {
                alert('Please select both start and end date/time for the breakdown.');
                return;
            }

            if (selectedMachines.length === 0) {
                alert('Please select at least one machine for the breakdown.');
                return;
            }

            if (new Date(start) >= new Date(end)) {
                alert('End date/time must be after start date/time.');
                return;
            }

            const breakdown = {
                id: Date.now(),
                machines: selectedMachines,
                start: start,
                end: end,
                reason: reason || 'Maintenance'
            };

            breakdowns.push(breakdown);
            window.breakdowns = breakdowns; // Update global reference
            updateBreakdownTable();
            clearBreakdownInputs();
        }

        function updateHolidayTable() {
            const tbody = document.getElementById('holidayTableBody');
            
            if (holidays.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #888;">No holidays added yet</td></tr>';
                return;
            }

            tbody.innerHTML = holidays.map(holiday => `
                <tr>
                    <td>${holiday.start}</td>
                    <td>${holiday.end}</td>
                    <td>${holiday.type}</td>
                    <td>${holiday.reason}</td>
                    <td>
                        <button class="btn btn-danger" onclick="removeHoliday(${holiday.id})">Delete</button>
                    </td>
                </tr>
            `).join('');
        }

        function updateBreakdownTable() {
            const tbody = document.getElementById('breakdownTableBody');
            
            if (breakdowns.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #888;">No breakdowns added yet</td></tr>';
                return;
            }

            tbody.innerHTML = breakdowns.map(breakdown => `
                <tr>
                    <td>${breakdown.machines.join(', ')}</td>
                    <td>${breakdown.start}</td>
                    <td>${breakdown.end}</td>
                    <td>${breakdown.reason}</td>
                    <td>
                        <button class="btn btn-danger" onclick="removeBreakdown(${breakdown.id})">Delete</button>
                    </td>
                </tr>
            `).join('');
        }

        function removeHoliday(id) {
            if (confirm('Are you sure you want to remove this holiday?')) {
                holidays = holidays.filter(h => h.id !== id);
                window.holidays = holidays; // Update global reference
                updateHolidayTable();
            }
        }

        function removeBreakdown(id) {
            if (confirm('Are you sure you want to remove this breakdown?')) {
                breakdowns = breakdowns.filter(b => b.id !== id);
                window.breakdowns = breakdowns; // Update global reference
                updateBreakdownTable();
            }
        }

        function clearHolidayInputs() {
            document.getElementById('holidayStart').value = '';
            document.getElementById('holidayEnd').value = '';
            document.getElementById('holidayReason').value = '';
        }

        function clearBreakdownInputs() {
            document.getElementById('breakdownStart').value = '';
            document.getElementById('breakdownEnd').value = '';
            document.getElementById('breakdownReason').value = '';
            document.querySelectorAll('#machineCheckboxGroup input:checked').forEach(cb => cb.checked = false);
        }

        // Auto-update setup window when shifts change
        function updateSetupWindow() {
            const shift1 = document.getElementById('shift1').value;
            const shift2 = document.getElementById('shift2').value;
            
            if (shift1 && shift2) {
                const start1 = shift1.split('-')[0];
                const end2 = shift2.split('-')[1];
                document.getElementById('setupAvailabilityWindow').value = `${start1}-${end2}`;
            }
        }

        function saveAdvancedSettings() {
            // Handle datetime-local input properly
            const startDateTimeValue = document.getElementById('startDateTime').value;
            let processedStartDateTime = null;
            
            if (startDateTimeValue) {
                // datetime-local input returns format like "2025-09-08T06:00"
                // We need to treat this as local time, not UTC
                const localDate = new Date(startDateTimeValue);
                processedStartDateTime = localDate.toISOString();
                console.log(`[UI-DEBUG] Global Start DateTime set to: ${processedStartDateTime}`);
            } else {
                console.log(`[UI-DEBUG] No Global Start DateTime set`);
            }
            
            advancedSettings = {
                startDateTime: processedStartDateTime,
                setupAvailabilityWindow: document.getElementById('setupAvailabilityWindow').value,
                shift1: document.getElementById('shift1').value,
                shift2: document.getElementById('shift2').value,
                prodShift1: document.getElementById('prodShift1').value,
                prodShift2: document.getElementById('prodShift2').value,
                prodShift3: document.getElementById('prodShift3').value,
                holidays: holidays,
                breakdowns: breakdowns
            };
            
            // Update global reference
            window.advancedSettings = advancedSettings;
            
            console.log(`[UI-DEBUG] Advanced settings saved:`, advancedSettings);
            showAlert('Advanced settings saved successfully!', 'success');
        }

        function loadAdvancedSettings() {
            // Load saved settings back into the UI
            if (advancedSettings.startDateTime) {
                // Convert ISO string back to datetime-local format
                const date = new Date(advancedSettings.startDateTime);
                const localDateTime = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
                document.getElementById('startDateTime').value = localDateTime.toISOString().slice(0, 16);
                console.log(`[UI-DEBUG] Loaded Global Start DateTime: ${advancedSettings.startDateTime} -> ${localDateTime.toISOString().slice(0, 16)}`);
            } else {
                document.getElementById('startDateTime').value = '';
            }
            
            document.getElementById('setupAvailabilityWindow').value = advancedSettings.setupAvailabilityWindow || '06:00-22:00';
            document.getElementById('shift1').value = advancedSettings.shift1 || '06:00-14:00';
            document.getElementById('shift2').value = advancedSettings.shift2 || '14:00-22:00';
            document.getElementById('prodShift1').value = advancedSettings.prodShift1 || '06:00-14:00';
            document.getElementById('prodShift2').value = advancedSettings.prodShift2 || '14:00-22:00';
            document.getElementById('prodShift3').value = advancedSettings.prodShift3 || '22:00-06:00';
            
            // Load holidays and breakdowns
            if (advancedSettings.holidays) {
                holidays = advancedSettings.holidays;
                window.holidays = holidays; // Update global reference
                updateHolidayTable();
            }
            
            if (advancedSettings.breakdowns) {
                breakdowns = advancedSettings.breakdowns;
                window.breakdowns = breakdowns; // Update global reference
                updateBreakdownTable();
            }
        }

        function toggleAdvanced() {
            const options = document.getElementById('advancedOptions');
            options.classList.toggle('show');
        }

        // Batch mode toggle functionality
        function setupBatchModeToggle() {
            console.log('Setting up batch mode toggle...');
            
            // Wait for DOM to be ready
            setTimeout(() => {
                const toggleContainer = document.querySelector('.three-way-toggle:not(#priorityToggle)');
                const toggleOptions = toggleContainer ? toggleContainer.querySelectorAll('.toggle-option') : [];
                console.log('Found batch mode toggle options:', toggleOptions.length);
                
                // Define the order of modes
                const modeOrder = ['single-batch', 'auto-split', 'custom-batch-size'];
                let currentModeIndex = 1; // Start with auto-split (index 1)
                
                // Set initial active state
                toggleOptions.forEach((option, index) => {
                    if (option.dataset.mode === modeOrder[currentModeIndex]) {
                        option.classList.add('active');
                    } else {
                        option.classList.remove('active');
                    }
                });
                
                // Add click event to each individual option
                toggleOptions.forEach((option, index) => {
                    option.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const clickedMode = this.dataset.mode;
                        console.log('Option clicked:', clickedMode);
                        
                        // Only change if clicking a different option
                        if (clickedMode !== modeOrder[currentModeIndex]) {
                            // Remove active class from all options
                            toggleOptions.forEach(opt => {
                                opt.classList.remove('active');
                            });
                            
                            // Add active class to clicked option
                            this.classList.add('active');
                            
                            // Update current mode index
                            currentModeIndex = modeOrder.indexOf(clickedMode);
                            
                            // Update hidden radio inputs
                            document.querySelectorAll('input[name="batchMode"]').forEach(input => {
                                input.checked = input.value === clickedMode;
                            });
                            
                            // Handle custom batch size input
                            const customInput = document.getElementById('customBatchSize');
                            const customText = document.getElementById('customSizeText');
                            
                            if (clickedMode === 'custom-batch-size') {
                                if (customInput) {
                                    customInput.style.display = 'inline-block';
                                    setTimeout(() => customInput.focus(), 100);
                                }
                                if (customText) {
                                    customText.style.display = 'none';
                                }
                            } else {
                                if (customInput) {
                                    customInput.style.display = 'none';
                                }
                                if (customText) {
                                    customText.style.display = 'inline';
                                }
                            }
                            
                            console.log('Batch mode set to:', clickedMode);
                        } else {
                            console.log('Same option clicked, no change needed');
                        }
                    });
                    
                    // Add hover effects
                    option.addEventListener('mouseenter', function() {
                        if (!this.classList.contains('active')) {
                            this.style.backgroundColor = '#f8f9fa'; // Light gray hover
                        }
                    });
                    
                    option.addEventListener('mouseleave', function() {
                        if (!this.classList.contains('active')) {
                            this.style.backgroundColor = ''; // Reset to CSS default (white)
                        }
                    });
                });
                
                // Ensure the toggle is visible and properly styled
                if (toggleContainer) {
                    toggleContainer.style.display = 'flex';
                    toggleContainer.style.visibility = 'visible';
                    toggleContainer.style.opacity = '1';
                    toggleContainer.style.height = '50px';
                    toggleContainer.style.maxWidth = '600px';
                    console.log('Toggle container visibility and styling set');
                }
                
                console.log('Initial active mode:', modeOrder[currentModeIndex]);
                
            }, 100);
        }

        function setupPriorityToggle() {
            console.log('Setting up priority toggle...');
            
            // Wait for DOM to be ready
            setTimeout(() => {
                const priorityToggleContainer = document.getElementById('priorityToggle');
                const priorityToggleOptions = priorityToggleContainer ? priorityToggleContainer.querySelectorAll('.toggle-option') : [];
                console.log('Found priority toggle options:', priorityToggleOptions.length);
                
                // Define the order of priority modes
                const priorityModeOrder = ['urgent', 'high', 'normal', 'low'];
                let currentPriorityIndex = 2; // Start with normal (index 2)
                
                // Set initial active state
                priorityToggleOptions.forEach((option, index) => {
                    if (option.dataset.mode === priorityModeOrder[currentPriorityIndex]) {
                        option.classList.add('active');
                    } else {
                        option.classList.remove('active');
                    }
                });
                
                // Add click event to each individual option
                priorityToggleOptions.forEach((option, index) => {
                    option.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const clickedMode = this.dataset.mode;
                        console.log('Priority option clicked:', clickedMode);
                        
                        // Only change if clicking a different option
                        if (clickedMode !== priorityModeOrder[currentPriorityIndex]) {
                            // Remove active class from all options
                            priorityToggleOptions.forEach(opt => {
                                opt.classList.remove('active');
                            });
                            
                            // Add active class to clicked option
                            this.classList.add('active');
                            
                            // Update current priority index
                            currentPriorityIndex = priorityModeOrder.indexOf(clickedMode);
                            
                            // Update hidden radio inputs
                            document.querySelectorAll('input[name="priority"]').forEach(input => {
                                input.checked = input.value === clickedMode.charAt(0).toUpperCase() + clickedMode.slice(1);
                            });
                            
                            console.log('Priority mode set to:', clickedMode);
                        } else {
                            console.log('Same priority option clicked, no change needed');
                        }
                    });
                    
                    // Add hover effects
                    option.addEventListener('mouseenter', function() {
                        if (!this.classList.contains('active')) {
                            this.style.backgroundColor = '#f8f9fa'; // Light gray hover
                        }
                    });
                    
                    option.addEventListener('mouseleave', function() {
                        if (!this.classList.contains('active')) {
                            this.style.backgroundColor = ''; // Reset to CSS default (white)
                        }
                    });
                });
                
                // Ensure the toggle is visible and properly styled
                if (priorityToggleContainer) {
                    priorityToggleContainer.style.display = 'flex';
                    priorityToggleContainer.style.visibility = 'visible';
                    priorityToggleContainer.style.opacity = '1';
                    priorityToggleContainer.style.height = '50px';
                    priorityToggleContainer.style.maxWidth = '600px';
                    console.log('Priority toggle container visibility and styling set');
                }
                
                console.log('Initial active priority:', priorityModeOrder[currentPriorityIndex]);
                
            }, 100);
        }

        function setupFormSubmission() {
            document.getElementById('orderForm').addEventListener('submit', function(e) {
                e.preventDefault();
                addOrder();
            });
            // Keep breakdown range always enabled; clear values if no machine selected
            const brMachineSel = document.getElementById('orderBreakdownMachine');
            const brStart = document.getElementById('orderBreakdownStart');
            const brEnd = document.getElementById('orderBreakdownEnd');
            if (brMachineSel) {
                brMachineSel.addEventListener('change', () => {
                    if (!brMachineSel.value) { brStart.value = ''; brEnd.value = ''; }
                });
            }
        }

        // Build breakdown range string like: "YYYY-MM-DD HH:MM → YYYY-MM-DD HH:MM"
        function buildBreakdownRangeString() {
            const machine = document.getElementById('orderBreakdownMachine').value;
            const s = document.getElementById('orderBreakdownStart').value;
            const e = document.getElementById('orderBreakdownEnd').value;
            if (!machine) return null; // machine not specified => treat as Global
            if (!s || !e) return null; // incomplete
            const start = new Date(s);
            const end = new Date(e);
            if (!(start instanceof Date) || isNaN(start) || !(end instanceof Date) || isNaN(end) || start >= end) return null;
            const startStr = s.replace('T', ' ');
            const endStr = e.replace('T', ' ');
            return `${startStr} → ${endStr}`;
        }

        // Parse stored range back into datetime-local inputs
        function parseBreakdownRangeToInputs(rangeStr) {
            if (!rangeStr || typeof rangeStr !== 'string') return { startVal: '', endVal: '' };
            const s = rangeStr.trim();
            let sep = '';
            if (s.includes('→')) sep = '→';
            else if (s.includes(' - ')) sep = ' - ';
            else if (s.toLowerCase().includes(' to ')) sep = ' to ';
            if (!sep) return { startVal: '', endVal: '' };
            const parts = s.split(sep);
            if (parts.length !== 2) return { startVal: '', endVal: '' };
            return { startVal: toLocalInput(parts[0].trim()), endVal: toLocalInput(parts[1].trim()) };
        }

        function toLocalInput(str) {
            if (!str) return '';
            // If already like YYYY-MM-DDTHH:MM
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(str)) return str;
            // If like YYYY-MM-DD HH:MM
            if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(str)) return str.replace(' ', 'T');
            // If like DD/MM/YYYY HH:MM
            const m = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4}) (\d{1,2}):(\d{2})$/);
            if (m) {
                const dd = m[1].padStart(2, '0');
                const mm = m[2].padStart(2, '0');
                const yyyy = m[3];
                const HH = m[4].padStart(2, '0');
                const MM = m[5];
                return `${yyyy}-${mm}-${dd}T${HH}:${MM}`;
            }
            // Fallback: try Date
            const d = new Date(str);
            if (isNaN(d)) return '';
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const HH = String(d.getHours()).padStart(2, '0');
            const MM = String(d.getMinutes()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}T${HH}:${MM}`;
        }

        // Build holiday range string like breakdown, but no enabling condition
        function buildHolidayRangeString() {
            const s = document.getElementById('orderHolidayStart').value;
            const e = document.getElementById('orderHolidayEnd').value;
            if (!s || !e) return null;
            const start = new Date(s);
            const end = new Date(e);
            if (!(start instanceof Date) || isNaN(start) || !(end instanceof Date) || isNaN(end) || start >= end) return null;
            return `${s.replace('T',' ')} → ${e.replace('T',' ')}`;
        }

        function parseHolidayRangeToInputs(rangeStr) {
            if (!rangeStr || typeof rangeStr !== 'string') return { startVal: '', endVal: '' };
            const s = rangeStr.trim();
            let sep = '';
            if (s.includes('→')) sep = '→';
            else if (s.includes(' - ')) sep = ' - ';
            else if (s.toLowerCase().includes(' to ')) sep = ' to ';
            if (!sep) return { startVal: '', endVal: '' };
            const parts = s.split(sep);
            if (parts.length !== 2) return { startVal: '', endVal: '' };
            return { startVal: toLocalInput(parts[0].trim()), endVal: toLocalInput(parts[1].trim()) };
        }

        function addOrder() {
            // Validate mandatory fields
            if (!selectedPartNumber) {
                alert('Please select a part number');
                return;
            }

            const quantity = parseInt(document.getElementById('orderQuantity').value);
            if (!quantity || quantity <= 0) {
                alert('Please enter a valid order quantity');
                return;
            }

            const priorityElement = document.querySelector('input[name="priority"]:checked');
            if (!priorityElement) {
                alert('Please select a priority');
                return;
            }

            const dueDate = document.getElementById('dueDate').value;
            if (!dueDate) {
                alert('Please select a due date');
                return;
            }

            // Ensure latest checkbox selections are captured even if OK wasn't clicked
            let operationSeq = document.getElementById('operationSeq').value;
            try {
                // If the dropdown exists, derive from its current checkbox state
                if (document.getElementById('operationDropdown')) {
                    operationSeq = deriveOperationSeqFromCheckboxes();
                }
            } catch (e) {
                console.warn('Failed deriving operation sequence from checkboxes, using hidden value:', e);
            }
            
            // Debug: Check what operation sequence value we're getting
            console.log('Order submission - operationSeq value:', operationSeq);
            console.log('Order submission - operationSeqDisplay value:', document.getElementById('operationSeqDisplay').value);
            
            // Filter operations based on selection
            const filteredOperations = getFilteredOperations(selectedPartNumber, operationSeq);
            if (filteredOperations.length === 0) {
                alert('No operations found for the selected criteria. Please check your operation selection.');
                return;
            }
            
            console.log('Order submission - Final filtered operations:', filteredOperations.map(op => `Op ${op.OperationSeq}: ${op.OperationName}`));

            // Capture batch mode
            const batchModeElement = document.querySelector('input[name="batchMode"]:checked');
            const batchMode = batchModeElement ? batchModeElement.value : 'auto-split';

            // Capture optional overrides
            const order = {
                id: editingOrderId !== null ? editingOrderId : Date.now(),
                partNumber: selectedPartNumber,
                operationSeq: operationSeq || null,
                filteredOperations: filteredOperations, // Store filtered operations
                quantity: quantity,
                priority: priorityElement.value,
                dueDate: dueDate,
                batchMode: batchMode,
                // Optional overrides (null if blank, will use global settings)
                breakdownMachine: document.getElementById('orderBreakdownMachine').value || null,
                breakdownDateTime: buildBreakdownRangeString(),
                startDateTime: document.getElementById('orderStartDateTime').value || null,
                holidayRange: buildHolidayRangeString(),
                setupWindow: document.getElementById('orderSetupWindow').value || null
            };

            if (editingOrderId !== null) {
                // Update existing order
                const idx = savedOrders.findIndex(o => o.id === editingOrderId);
                if (idx !== -1) savedOrders[idx] = order; else savedOrders.push(order);
                updateOrdersTable();
                exitEditMode();
                showAlert('Order updated successfully! Click "Run Schedule" to generate results.', 'success');
            } else {
                // Create new order
                savedOrders.push(order);
                updateOrdersTable();
                resetForm();
                showAlert('Order added successfully!', 'success');
            }
        }

        function getFilteredOperations(partNumber, operationSeq) {
            // Use test data if available, otherwise use database data
            const dataSource = isUsingTestData ? testUserData : window.OP_MASTER;
            
            // Get all operations for this part number from data source
            const allOperations = dataSource.filter(op => {
                const partNum = op.PartNumber || op.partnumber;
                return partNum === partNumber;
            });
            
            console.log(`Found ${allOperations.length} total operations for ${partNumber}:`, 
                allOperations.map(op => `Op ${op.OperationSeq || op.operationseq}: ${op.OperationName || op.operationname}`));
            
            if (!operationSeq || operationSeq === '') {
                // "All operations" selected - include everything
                console.log('Selected: ALL operations');
                return allOperations.sort((a, b) => (a.OperationSeq || a.operationseq) - (b.OperationSeq || b.operationseq));
            } else {
                // Specific operations selected (e.g., "1,2" or "3,4")
                const selectedSeqs = operationSeq.split(',').map(seq => parseInt(seq.trim()));
                console.log('Selected operation sequences:', selectedSeqs);
                
                const filteredOps = allOperations.filter(op => {
                    const opSeq = op.OperationSeq || op.operationseq;
                    return selectedSeqs.includes(opSeq);
                });
                console.log(`Filtered to ${filteredOps.length} operations:`, 
                    filteredOps.map(op => `Op ${op.OperationSeq || op.operationseq}: ${op.OperationName || op.operationname}`));
                
                // CRITICAL: Only return operations that match the selected sequences
                // This prevents any excluded operations from appearing in results
                return filteredOps.sort((a, b) => (a.OperationSeq || a.operationseq) - (b.OperationSeq || b.operationseq));
            }
        }

        function toggleOptionalOverrides() {
            const content = document.getElementById('optionalOverridesContent');
            const icon = document.getElementById('overrideToggleIcon');
            
            if (content.style.display === 'none') {
                content.style.display = 'grid';
                icon.textContent = '▼';
                icon.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                icon.textContent = '▶';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        function clearForm() {
            document.getElementById('orderForm').reset();
            document.getElementById('partSuggestions').style.display = 'none';
            document.getElementById('operationDropdown').style.display = 'none';
            document.getElementById('operationSeqBtn').disabled = true;
            document.getElementById('operationSeqDisplay').disabled = true;
            document.getElementById('operationSeqDisplay').placeholder = 'Select a part number first';
            document.getElementById('optionalOverridesContent').style.display = 'none';
            document.getElementById('overrideToggleIcon').textContent = '▶';
            
            // Reset batch mode toggle to default
            document.querySelectorAll('.toggle-option').forEach(opt => opt.classList.remove('active'));
            document.querySelector('.toggle-option[data-mode="auto-split"]').classList.add('active');
            document.querySelectorAll('input[name="batchMode"]').forEach(input => {
                input.checked = input.value === 'auto-split';
            });
            
            // Hide custom batch size input
            const customInput = document.getElementById('customBatchSize');
            const customText = document.getElementById('customSizeText');
            customInput.style.display = 'none';
            customText.style.display = 'inline';
        }

        function resetForm() {
            document.getElementById('orderForm').reset();
            selectedPartNumber = '';
            setDefaultDueDate();
            // Clear holiday range explicitly (since reset may not affect datetime-local consistently across browsers)
            const holStart = document.getElementById('orderHolidayStart');
            const holEnd = document.getElementById('orderHolidayEnd');
            if (holStart) holStart.value = '';
            if (holEnd) holEnd.value = '';
            document.querySelector('input[name="priority"][value="Normal"]').checked = true;
            
            // Reset optional overrides section to collapsed state
            document.getElementById('optionalOverridesContent').style.display = 'none';
            document.getElementById('overrideToggleIcon').textContent = '▶';
            document.getElementById('overrideToggleIcon').style.transform = 'rotate(0deg)';
        }

        function updateOrdersTable() {
            const tbody = document.getElementById('ordersTableBody');
            
            if (savedOrders.length === 0) {
                tbody.innerHTML = '<tr><td colspan="12" class="empty-state">No orders added yet</td></tr>';
                return;
            }

            tbody.innerHTML = savedOrders.map(order => {
                // Display operation sequences more clearly
                let operationDisplay = 'All';
                if (order.filteredOperations && order.filteredOperations.length > 0) {
                    // Prefer the actual filtered ops list for accuracy
                    operationDisplay = order.filteredOperations.map(op => `Op ${op.OperationSeq}`).join(', ');
                } else if (order.operationSeq) {
                    operationDisplay = order.operationSeq;
                }
                
                // Determine batch mode display
                let batchModeDisplay = 'Auto';
                let batchModeClass = 'auto-split';
                if (order.batchMode) {
                    if (order.batchMode === 'single-batch') {
                        batchModeDisplay = 'Single';
                        batchModeClass = 'single-batch';
                    } else if (order.batchMode === 'custom-batch-size') {
                        batchModeDisplay = 'Custom';
                        batchModeClass = 'custom';
                    }
                }
                
                return `
                <tr>
                    <td>${order.partNumber}</td>
                    <td>${operationDisplay}</td>
                    <td>${order.quantity}</td>
                    <td><span class="priority-badge priority-${order.priority.toLowerCase()}">${order.priority}</span></td>
                    <td>${new Date(order.dueDate).toLocaleDateString()}</td>
                    <td><span class="batch-mode-badge batch-mode-${batchModeClass}">${batchModeDisplay}</span></td>
                    <td>${order.breakdownMachine || 'None'}</td>
                    <td>${order.breakdownDateTime || 'None'}</td>
                    <td>${order.startDateTime ? new Date(order.startDateTime).toLocaleString() : 'Use Global'}</td>
                    <td>${order.holidayRange || 'None'}</td>
                    <td>${order.setupWindow || '06:00-22:00'}</td>
                    <td>
                        <div class="action-buttons">
                            <button class="btn btn-primary" onclick="editOrder(${order.id})" title="Edit Order">✏️</button>
                            <button class="btn btn-warning" onclick="duplicateOrder(${order.id})" title="Duplicate Order">📋</button>
                            <button class="btn btn-info" onclick="viewOrderDetails(${order.id})" title="View Details">👁️</button>
                            <button class="btn btn-danger" onclick="deleteOrder(${order.id})" title="Delete Order">🗑️</button>
                        </div>
                    </td>
                </tr>
                `;
            }).join('');
        }

        function deleteOrder(orderId) {
            if (confirm('Are you sure you want to delete this order?')) {
                savedOrders = savedOrders.filter(order => order.id !== orderId);
                updateOrdersTable();
                showAlert('Order deleted successfully!', 'success');
            }
        }

        function duplicateOrder(orderId) {
            const order = savedOrders.find(o => o.id === orderId);
            if (order) {
                const newOrder = {
                    ...order,
                    id: Date.now(),
                    partNumber: order.partNumber + '_COPY',
                    dueDate: ''
                };
                savedOrders.push(newOrder);
                updateOrdersTable();
                alert(`Order duplicated successfully! New order ID: ${newOrder.id}`);
            }
        }

        function viewOrderDetails(orderId) {
            const order = savedOrders.find(o => o.id === orderId);
            if (order) {
                const details = `
Order Details:
• Part Number: ${order.partNumber}
• Operation: ${order.operationSeq || 'All'}
• Quantity: ${order.quantity}
• Priority: ${order.priority}
• Due Date: ${order.dueDate || 'No due date'}
• Batch Mode: ${order.batchMode || 'Auto-Split'}
• Breakdown Machine: ${order.breakdownMachine || 'None'}
• Breakdown DateTime: ${order.breakdownDateTime || 'None'}
• Start DateTime: ${order.startDateTime || 'Use Global'}
• Holiday: ${order.holidayRange || 'None'}
• Setup Window: ${order.setupWindow || '06:00-22:00'}
                `;
                alert(details);
            }
        }

        function clearAllSavedOrders() {
            if (savedOrders.length === 0) {
                alert('No orders to clear.');
                return;
            }

            if (confirm(`Are you sure you want to delete all ${savedOrders.length} orders? This action cannot be undone.`)) {
                savedOrders = [];
                updateOrdersTable();
                alert('All orders cleared successfully!');
            }
        }

        // Enter edit mode with an existing order
        function editOrder(orderId) {
            const order = savedOrders.find(o => o.id === orderId);
            if (!order) return;
            editingOrderId = order.id;

            // Show Orders tab
            document.getElementById('ordersTab').style.display = 'block';
            document.getElementById('advancedTab').style.display = 'none';

            // Prefill fields
            selectedPartNumber = order.partNumber;
            const partInput = document.getElementById('partNumber');
            partInput.value = order.partNumber;
            partInput.disabled = true; // lock part number during edit

            // Populate operations for part and set selection
            populateOperationSequences(order.partNumber);
            const opDisplay = document.getElementById('operationSeqDisplay');
            const opHidden = document.getElementById('operationSeq');
            opHidden.value = order.operationSeq || '';
            if (!order.operationSeq || order.operationSeq === '') {
                opDisplay.value = 'All operations';
            } else {
                const seqs = order.operationSeq.split(',').map(s => s.trim()).filter(Boolean);
                opDisplay.value = seqs.map(s => `Op ${s}`).join(', ');
            }

            document.getElementById('orderQuantity').value = order.quantity;
            const priorityValue = order.priority || 'Normal';
            const prRadio = document.querySelector(`input[name="priority"][value="${priorityValue}"]`);
            if (prRadio) prRadio.checked = true;
            document.getElementById('dueDate').value = order.dueDate;
            
            // Set batch mode
            const batchModeValue = order.batchMode || 'auto-split';
            const batchModeRadio = document.querySelector(`input[name="batchMode"][value="${batchModeValue}"]`);
            if (batchModeRadio) {
                batchModeRadio.checked = true;
                // Update toggle visual state
                document.querySelectorAll('.toggle-option').forEach(opt => opt.classList.remove('active'));
                const activeToggle = document.querySelector(`.toggle-option[data-mode="${batchModeValue}"]`);
                if (activeToggle) activeToggle.classList.add('active');
            }

            document.getElementById('orderBreakdownMachine').value = order.breakdownMachine || '';
            // Prefill breakdown range fields
            const { startVal, endVal } = parseBreakdownRangeToInputs(order.breakdownDateTime || '');
            const brStart = document.getElementById('orderBreakdownStart');
            const brEnd = document.getElementById('orderBreakdownEnd');
            brStart.value = startVal;
            brEnd.value = endVal;
            const brMachineSel = document.getElementById('orderBreakdownMachine');
            document.getElementById('orderStartDateTime').value = order.startDateTime || '';
            // Prefill holiday range
            const { startVal: holS, endVal: holE } = parseHolidayRangeToInputs(order.holidayRange || '');
            const holStart = document.getElementById('orderHolidayStart');
            const holEnd = document.getElementById('orderHolidayEnd');
            holStart.value = holS;
            holEnd.value = holE;
            document.getElementById('orderSetupWindow').value = order.setupWindow || '';

            // Update buttons
            document.getElementById('orderSubmitBtn').textContent = '✔️ Update Order';
            document.getElementById('cancelEditBtn').style.display = 'inline-flex';
        }

        function cancelEdit() { exitEditMode(); }

        function exitEditMode() {
            editingOrderId = null;
            // unlock part input
            const partInput = document.getElementById('partNumber');
            partInput.disabled = false;
            resetForm();
            document.getElementById('orderSubmitBtn').textContent = '➕ Add Order';
            document.getElementById('cancelEditBtn').style.display = 'none';
        }

        // Schedule only a single order
        function runScheduleForSingleOrder(order) {
            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('resultsCard').style.display = 'none';

            setTimeout(() => {
                try {
                    const single = processOrderSingle(order);
                    scheduleResults = single; // show only this order
                    displayResults();
                    document.getElementById('exportBtn').disabled = false;
                } catch (error) {
                    console.error('Scheduling error (single):', error);
                    showAlert('Error generating schedule for updated order: ' + error.message, 'error');
                } finally {
                    document.getElementById('loadingIndicator').style.display = 'none';
                }
            }, 300);
        }

        // Process a single order using the same pipeline rules
        function processOrderSingle(order) {
            const results = [];
            const alerts = [];
            const machineSchedule = {}; // Track when each machine is available
            const operatorSchedule = {}; // Track operator availability per shift
            const allMachines = ["VMC 1", "VMC 2", "VMC 3", "VMC 4", "VMC 5", "VMC 6", "VMC 7"];
            allMachines.forEach(m => machineSchedule[m] = getNextShiftStart());
            ;["A","B","C","D"].forEach(p => operatorSchedule[p] = getNextShiftStart());

            let operations = Array.isArray(order.filteredOperations) ? order.filteredOperations.slice() : [];
            if (operations.length === 0) {
                alerts.push(`No filtered operations present for ${order.partNumber}.`);
                return { rows: results, alerts };
            }
            if (order.operationSeq && order.operationSeq !== '') {
                const selectedSeqs = order.operationSeq.split(',').map(s => parseInt(s.trim()));
                operations = operations.filter(op => selectedSeqs.includes(op.OperationSeq));
            }

            const opResults = calculatePieceLevelScheduling(operations, order, machineSchedule, operatorSchedule);
            opResults.forEach(opResult => {
                machineSchedule[opResult.Machine] = opResult.actualRunEnd;
                operatorSchedule[opResult.Person] = opResult.actualRunEnd;
                results.push({
                    PartNumber: order.partNumber,
                    Order_Quantity: order.quantity,
                    Priority: order.priority,
                    Batch_ID: `${order.partNumber}-${opResult.OperationSeq}`,
                    Batch_Qty: order.quantity,
                    OperationSeq: opResult.OperationSeq,
                    OperationName: opResult.OperationName,
                    Machine: opResult.Machine,
                    Person: opResult.Person,
                    SetupStart: formatDateTime(opResult.SetupStart),
                    SetupEnd: formatDateTime(opResult.SetupEnd),
                    RunStart: formatDateTime(opResult.RunStart),
                    RunEnd: formatDateTime(opResult.RunEnd),
                    Timing: opResult.Timing,
                    DueDate: formatDate(order.dueDate)
                });
            });
            return { rows: results, alerts };
        }

        async function runSchedule() {
            if (savedOrders.length === 0) {
                alert('Please add at least one order before running the schedule');
                return;
            }

            try {
                const userRole = await getCurrentUserRole();
                
                // For Test Users, ensure they have imported data
                if (userRole === 'Test User' && !isUsingTestData) {
                    showAlert('Test users must import Excel data first before running schedule', 'error');
                    return;
                }

                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('resultsCard').style.display = 'none';

                // Simulate processing time
                setTimeout(() => {
                try {
                    // Use the NEW scheduling engine from x10-browser.js
                    const ordersData = savedOrders.map(order => {
                        // Normalize operations data for test users
                        let operations = order.filteredOperations || [];
                        if (isUsingTestData && operations.length > 0) {
                            operations = operations.map(op => ({
                                PartNumber: op.partnumber || op.PartNumber,
                                OperationSeq: op.operationseq || op.OperationSeq,
                                OperationName: op.operationname || op.OperationName,
                                SetupTime_Min: op.setuptime_min || op.SetupTime_Min,
                                Operator: op.operator || op.Operator,
                                CycleTime_Min: op.cycletime_min || op.CycleTime_Min,
                                Minimum_BatchSize: op.minimum_batchsize || op.Minimum_BatchSize,
                                EligibleMachines: op.eligiblemachines || op.EligibleMachines
                            }));
                        }
                        
                        return {
                            partNumber: order.partNumber,
                            quantity: order.quantity,
                            priority: order.priority,
                            dueDate: order.dueDate,
                            operations: operations,
                            breakdownMachine: order.breakdownMachine,
                            breakdownDateTime: order.breakdownDateTime,
                            startDateTime: order.startDateTime,
                            holidayRange: order.holidayRange,
                            setupWindow: order.setupWindow
                        };
                    });

                    const globalSettings = {
                        startDateTime: advancedSettings.startDateTime,
                        setupWindow: advancedSettings.setupAvailabilityWindow,
                        breakdownMachines: advancedSettings.breakdownMachines,
                        breakdownDateTime: advancedSettings.breakdownDateTime,
                        holidays: advancedSettings.holidays || [],
                        breakdowns: advancedSettings.breakdowns || [],
                        shifts: {
                            shift1: advancedSettings.shift1,
                            shift2: advancedSettings.shift2,
                            shift3: advancedSettings.shift3
                        }
                    };

                    // Call the NEW scheduling engine
                    scheduleResults = window.runScheduling(ordersData, globalSettings);
                    displayResults();
                    document.getElementById('exportBtn').disabled = false;
                    showAlert('Schedule generated successfully with new engine!', 'success');
                } catch (error) {
                    console.error('Scheduling error:', error);
                    showAlert('Error generating schedule: ' + error.message, 'error');
                } finally {
                    document.getElementById('loadingIndicator').style.display = 'none';
                }
            }, 1000);
            } catch (error) {
                console.error('Schedule initialization error:', error);
                showAlert('Error initializing schedule: ' + error.message, 'error');
                document.getElementById('loadingIndicator').style.display = 'none';
            }
        }

        function processOrders() {
            const results = [];
            const alerts = [];
            const machineSchedule = {}; // Track when each machine is available
            const operatorSchedule = {}; // Track operator availability per shift
            const operators = ["A", "B", "C", "D"];
            
            // Initialize machine and operator tracking
            const allMachines = ["VMC 1", "VMC 2", "VMC 3", "VMC 4", "VMC 5", "VMC 6", "VMC 7"];
            allMachines.forEach(machine => {
                machineSchedule[machine] = getNextShiftStart();
            });
            
            // Initialize operator schedules
            operators.forEach(op => {
                operatorSchedule[op] = getNextShiftStart();
            });

            // Sort orders by priority and due date
            const sortedOrders = [...savedOrders].sort((a, b) => {
                const priorityWeight = { Urgent: 4, High: 3, Normal: 2, Low: 1 };
                if (priorityWeight[a.priority] !== priorityWeight[b.priority]) {
                    return priorityWeight[b.priority] - priorityWeight[a.priority];
                }
                return new Date(a.dueDate) - new Date(b.dueDate);
            });

            sortedOrders.forEach(order => {
                // CRITICAL: Use ONLY pre-filtered operations from order submission
                // This ensures excluded operations never appear in results
                let operations = Array.isArray(order.filteredOperations) ? order.filteredOperations.slice() : [];
                
                // STRICT: Never rebuild from OP_MASTER here. If empty, skip this order with an alert.
                if (operations.length === 0) {
                    const msg = `No filtered operations present for ${order.partNumber}. Skipping this order to enforce strict filtering.`;
                    console.warn(msg);
                    alerts.push(msg);
                    return;
                }
                
                if (operations.length === 0) {
                    alerts.push(`No operations found for part number: ${order.partNumber}`);
                    return;
                }

                // STRICT ENFORCEMENT: Only process selected operations
                console.log(`SCHEDULING: Processing ${operations.length} operations for ${order.partNumber}:`, 
                    operations.map(op => `Op ${op.OperationSeq}: ${op.OperationName}`));
                console.log(`Order operationSeq setting: "${order.operationSeq}"`);
                
                // Final verification: ensure operations match selection
                if (order.operationSeq && order.operationSeq !== '') {
                    const selectedSeqs = order.operationSeq.split(',').map(seq => parseInt(seq.trim()));
                    const beforeCount = operations.length;
                    operations = operations.filter(op => selectedSeqs.includes(op.OperationSeq));
                    console.log(`STRICT FILTER: Reduced from ${beforeCount} to ${operations.length} operations`);
                    console.log(`FINAL OPERATIONS TO PROCESS:`, operations.map(op => `Op ${op.OperationSeq}`));
                }

                // Batch splitting by priority and due constraints
                const batches = splitOrderIntoBatches(order);
                batches.forEach((batch, idx) => {
                    const batchId = `${order.partNumber}-${idx + 1}`;
                    const batchOrder = { ...order, quantity: batch.qty };
                    const operationResults = calculatePieceLevelScheduling(operations, batchOrder, machineSchedule, operatorSchedule);

                    // Determine batch completion and due compliance
                    const lastOp = operationResults[operationResults.length - 1];
                    const batchCompletion = lastOp ? lastOp.RunEnd : null;
                    const due = new Date(order.dueDate);
                    const isOnTime = batchCompletion ? (new Date(batchCompletion).getTime() <= due.getTime() + (24*60*60*1000 - 1)) : true; // same-day due
                    const dueMark = isOnTime ? '✅' : '⚠️';
                    if (order.priority === 'Urgent' && !isOnTime && batchCompletion) {
                        const lateMs = new Date(batchCompletion).getTime() - due.getTime();
                        const lateHrs = Math.ceil(lateMs / 3600000);
                        alerts.push(`High Risk: ${order.partNumber} batch ${idx + 1} expected late by ~${lateHrs}h (due ${formatDate(order.dueDate)}).`);
                    }

                    operationResults.forEach(opResult => {
                        // Update resource schedules at each op
                        machineSchedule[opResult.Machine] = opResult.actualRunEnd;
                        operatorSchedule[opResult.Person] = opResult.actualRunEnd;

                        results.push({
                            PartNumber: order.partNumber,
                            Order_Quantity: order.quantity,
                            Priority: order.priority,
                            Batch_ID: batchId,
                            Batch_Qty: batch.qty,
                            OperationSeq: opResult.OperationSeq,
                            OperationName: opResult.OperationName,
                            Machine: opResult.Machine,
                            Person: opResult.Person,
                            SetupStart: formatDateTime(opResult.SetupStart),
                            SetupEnd: formatDateTime(opResult.SetupEnd),
                            RunStart: formatDateTime(opResult.RunStart),
                            RunEnd: formatDateTime(opResult.RunEnd),
                            Timing: opResult.Timing,
                            DueDate: `${formatDate(order.dueDate)} ${dueMark}`
                        });
                    });
                });
            });

            return { rows: results, alerts: alerts };
        }

        // Split total order quantity into batches based on priority
        function splitOrderIntoBatches(order) {
            const qty = Number(order.quantity) || 0;
            if (qty <= 0) return [];
            let parts = 1;
            switch ((order.priority || 'Normal')) {
                case 'Urgent': parts = Math.min(4, Math.max(1, qty)); break; // up to 4 smaller batches
                case 'High': parts = Math.min(3, Math.max(1, qty >= 3 ? 3 : qty)); break;
                case 'Normal': parts = Math.min(2, Math.max(1, qty >= 2 ? 2 : qty)); break;
                case 'Low': default: parts = 1; break;
            }
            const base = Math.floor(qty / parts);
            const rem = qty % parts;
            const batches = [];
            for (let i = 0; i < parts; i++) {
                batches.push({ qty: base + (i < rem ? 1 : 0) });
            }
            return batches;
        }

        function getNextShiftStart() {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            
            // Shift times: 06:00-14:00, 14:00-22:00
            const morningShift = new Date(today.getTime() + (6 * 60 * 60 * 1000)); // 06:00
            const eveningShift = new Date(today.getTime() + (14 * 60 * 60 * 1000)); // 14:00
            const nextMorning = new Date(today.getTime() + (24 + 6) * 60 * 60 * 1000); // Next day 06:00
            
            if (now < morningShift) return morningShift;
            if (now < eveningShift) return eveningShift;
            return nextMorning;
        }

        function calculateShiftAwareSchedule(machineAvailableTime, operatorAvailableTime, setupTime, runTime, orderSettings = null) {
            // CRITICAL FIX: Use the fixed start time from the test instead of current time
            const fixedStartTime = new Date('2025-09-01T06:00:00');
            let startTime = new Date(Math.max(machineAvailableTime.getTime(), operatorAvailableTime.getTime(), fixedStartTime.getTime()));
            
            // LAYER 1: Setup Layer (People-Dependent) - HARD CONSTRAINT Setup Window Enforcement
            const setupWindowStr = orderSettings ? orderSettings.setupWindow : getSetupWindow();
            console.log('Getting setup window string:', setupWindowStr);
            const setupWindow = parseSetupWindow(setupWindowStr);
            
            // FORCE SETUP INTO WINDOW - NO EXCEPTIONS
            console.log('Original start time before enforcement:', startTime.toISOString());
            
            // If current time is outside setup window, FORCE to next valid window
            const currentHour = startTime.getHours();
            if (currentHour < setupWindow.start) {
                // Before window - move to start of window (same day or next day)
                startTime.setHours(setupWindow.start, 0, 0, 0);
                console.log('Moved to window start (before):', startTime.toISOString());
            } else if (currentHour >= setupWindow.end) {
                // After window - move to NEXT DAY's window start
                startTime.setDate(startTime.getDate() + 1);
                startTime.setHours(setupWindow.start, 0, 0, 0);
                console.log('Moved to next day window start (after):', startTime.toISOString());
            }
            
            let setupStart = new Date(startTime);
            
            // Step 2: Validate entire setup (start + duration) fits within window
            const validatedSetup = validateSetupWithinWindow(setupStart, setupTime, setupWindow);
            setupStart = validatedSetup.setupStart;
            let setupEnd = validatedSetup.setupEnd;
            
            // Step 3: Ensure operators are available during setup time
            const setupShift = getSetupShift(setupStart);
            if (!setupShift.hasOperators) {
                // Move to next available setup window with operators
                setupStart = getNextSetupWindow(setupStart, setupWindow);
                // Re-validate after moving to next window
                const revalidatedSetup = validateSetupWithinWindow(setupStart, setupTime, setupWindow);
                setupStart = revalidatedSetup.setupStart;
                setupEnd = revalidatedSetup.setupEnd;
            }
            
            // LAYER 2: Production Layer (Machine-Dependent) - Respects Production Shifts
            const productionShifts = getProductionShifts();
            const runSchedule = calculateProductionWithShiftBoundaries(setupEnd, runTime, productionShifts);
            
            // Calculate total timing including setup + production
            const totalElapsed = (runSchedule.runEnd.getTime() - setupStart.getTime()) / (1000 * 60);
            const actualWork = setupTime + runTime;
            const totalPausedTime = totalElapsed - actualWork;
            
            return {
                setupStart,
                setupEnd,
                runStart: runSchedule.runStart,
                runEnd: runSchedule.runEnd,
                timingDescription: `${formatDuration(totalElapsed)} total (${totalPausedTime > 0 ? formatDuration(totalPausedTime) + ' paused, ' : ''}${formatDuration(actualWork)} work)`
            };
        }

        function getSetupShift(time) {
            const hour = time.getHours();
            if (hour >= 6 && hour < 14) {
                return { shift: 1, operators: ['A', 'B'], hasOperators: true };
            } else if (hour >= 14 && hour < 22) {
                return { shift: 2, operators: ['C', 'D'], hasOperators: true };
            } else {
                return { shift: 3, operators: [], hasOperators: false }; // Night shift - no setups
            }
        }

        function enforceSetupWindow(time, setupWindow) {
            const hour = time.getHours();
            const minute = time.getMinutes();
            
            console.log('Enforcing Setup Window:', {
                originalTime: time.toISOString(),
                hour: hour,
                minute: minute,
                setupWindow: setupWindow
            });
            
            // HARD CONSTRAINT: Setup can ONLY occur within Setup Window
            
            // If before setup window start, move to start of window (same day or next day)
            if (hour < setupWindow.start) {
                const newTime = new Date(time);
                newTime.setHours(setupWindow.start, 0, 0, 0);
                console.log('Moved to window start (before):', newTime.toISOString());
                return newTime;
            }
            
            // If at or after setup window end, move to NEXT DAY's window start
            if (hour >= setupWindow.end) {
                const nextDay = new Date(time);
                nextDay.setDate(nextDay.getDate() + 1);
                nextDay.setHours(setupWindow.start, 0, 0, 0);
                console.log('Moved to next day window start (after):', nextDay.toISOString());
                return nextDay;
            }
            
            // Within window, return as-is
            console.log('Within window, keeping time:', time.toISOString());
            return new Date(time);
        }

        function validateSetupWithinWindow(setupStart, setupDuration, setupWindow) {
            const setupEnd = new Date(setupStart.getTime() + setupDuration * 60000);
            const setupEndHour = setupEnd.getHours();
            
            // CRITICAL: If setup would end AFTER window end time, move ENTIRE setup to next day
            if (setupEndHour > setupWindow.end || (setupEndHour === setupWindow.end && setupEnd.getMinutes() > 0)) {
                // Move entire setup to next day's window start
                const nextDay = new Date(setupStart);
                nextDay.setDate(nextDay.getDate() + 1);
                nextDay.setHours(setupWindow.start, 0, 0, 0);
                return {
                    setupStart: nextDay,
                    setupEnd: new Date(nextDay.getTime() + setupDuration * 60000)
                };
            }
            
            return {
                setupStart: setupStart,
                setupEnd: setupEnd
            };
        }

        function getNextSetupWindow(currentTime, setupWindow) {
            const nextDay = new Date(currentTime);
            nextDay.setDate(nextDay.getDate() + 1);
            nextDay.setHours(setupWindow.start, 0, 0, 0);
            return nextDay;
        }

        function getProductionShifts() {
            const productionWindow = getProductionWindow();
            const shifts = getShifts();
            
            switch (productionWindow) {
                case '24x7':
                    return [
                        { start: 0, end: 24 * 60, enabled: true } // 24x7 continuous
                    ];
                case '2-shift':
                    return [
                        { start: 6 * 60, end: 22 * 60, enabled: true } // 06:00-22:00
                    ];
                case '3-shift':
                    return [
                        { start: 6 * 60, end: 14 * 60, enabled: true },   // 06:00-14:00
                        { start: 14 * 60, end: 22 * 60, enabled: true },  // 14:00-22:00
                        { start: 22 * 60, end: 6 * 60 + 24 * 60, enabled: true } // 22:00-06:00 (next day)
                    ];
                default:
                    return [
                        { start: 0, end: 24 * 60, enabled: true }
                    ];
            }
        }

        function getProductionWindow() {
            const productionSelect = document.getElementById('productionWindow');
            return productionSelect ? productionSelect.value : '24x7';
        }

        function calculateProductionWithShiftBoundaries(runStart, runTimeMinutes, productionShifts) {
            let currentTime = new Date(runStart);
            let remainingTime = runTimeMinutes;
            const segments = [];
            let totalPausedTime = 0;

            while (remainingTime > 0) {
                const currentShift = findCurrentProductionShift(currentTime, productionShifts);
                
                if (!currentShift) {
                    // No production allowed at this time, move to next shift
                    const nextShift = findNextProductionShift(currentTime, productionShifts);
                    const pauseTime = (nextShift.getTime() - currentTime.getTime()) / (1000 * 60);
                    totalPausedTime += pauseTime;
                    currentTime = nextShift;
                    continue;
                }

                // Calculate how much time we can run in this shift
                const shiftEndTime = getShiftEndTime(currentTime, currentShift);
                const timeUntilShiftEnd = (shiftEndTime.getTime() - currentTime.getTime()) / (1000 * 60);
                const timeToRun = Math.min(remainingTime, timeUntilShiftEnd);
                
                const segmentEnd = new Date(currentTime.getTime() + timeToRun * 60000);
                segments.push({
                    start: new Date(currentTime),
                    end: segmentEnd,
                    duration: timeToRun
                });

                remainingTime -= timeToRun;
                currentTime = segmentEnd;

                // If we need more time, move to next shift
                if (remainingTime > 0) {
                    const nextShift = findNextProductionShift(currentTime, productionShifts);
                    if (nextShift.getTime() > currentTime.getTime()) {
                        const pauseTime = (nextShift.getTime() - currentTime.getTime()) / (60 * 1000);
                        totalPausedTime += pauseTime;
                    }
                    currentTime = nextShift;
                }
            }

            const finalRunEnd = segments[segments.length - 1].end;
            
            return {
                runStart,
                runEnd: finalRunEnd,
                segments,
                totalPausedTime
            };
        }

        function findCurrentProductionShift(time, productionShifts) {
            const dayMinutes = time.getHours() * 60 + time.getMinutes();
            
            for (const shift of productionShifts) {
                if (shift.enabled) {
                    // Handle overnight shifts (e.g., 22:00-06:00)
                    if (shift.start > shift.end) {
                        if (dayMinutes >= shift.start || dayMinutes < shift.end) {
                            return shift;
                        }
                    } else {
                        if (dayMinutes >= shift.start && dayMinutes < shift.end) {
                            return shift;
                        }
                    }
                }
            }
            return null;
        }

        function findNextProductionShift(time, productionShifts) {
            const dayMinutes = time.getHours() * 60 + time.getMinutes();
            let nextShiftStart = null;
            let nextDay = false;

            // Find the next enabled shift
            for (const shift of productionShifts) {
                if (shift.enabled) {
                    if (shift.start > dayMinutes) {
                        if (!nextShiftStart || shift.start < nextShiftStart) {
                            nextShiftStart = shift.start;
                        }
                    }
                }
            }

            // If no shift found today, get first shift of next day
            if (!nextShiftStart) {
                for (const shift of productionShifts) {
                    if (shift.enabled) {
                        if (!nextShiftStart || shift.start < nextShiftStart) {
                            nextShiftStart = shift.start;
                            nextDay = true;
                        }
                    }
                }
            }

            const nextTime = new Date(time);
            if (nextDay) {
                nextTime.setDate(nextTime.getDate() + 1);
            }
            nextTime.setHours(Math.floor(nextShiftStart / 60), nextShiftStart % 60, 0, 0);
            return nextTime;
        }

        function getShiftEndTime(time, shift) {
            const endTime = new Date(time);
            
            // Handle overnight shifts
            if (shift.start > shift.end) {
                if (time.getHours() * 60 + time.getMinutes() >= shift.start) {
                    // We're in the first part of overnight shift, end is next day
                    endTime.setDate(endTime.getDate() + 1);
                }
            }
            
            endTime.setHours(Math.floor(shift.end / 60), shift.end % 60, 0, 0);
            return endTime;
        }

        function getCurrentProductionShift(time, productionWindow) {
            const hour = time.getHours();
            
            switch (productionWindow) {
                case '24x7':
                    return { isProductionAllowed: true, minutesUntilEnd: 24 * 60 }; // Always allowed
                    
                case '2-shift':
                    if (hour >= 6 && hour < 22) {
                        const minutesUntilEnd = (22 - hour) * 60 - time.getMinutes();
                        return { isProductionAllowed: true, minutesUntilEnd };
                    }
                    return { isProductionAllowed: false, minutesUntilEnd: 0 };
                    
                case '3-shift':
                    // 3 shifts with boundaries: 06:00-14:00, 14:00-22:00, 22:00-06:00
                    let shiftEnd;
                    if (hour >= 6 && hour < 14) {
                        shiftEnd = 14;
                    } else if (hour >= 14 && hour < 22) {
                        shiftEnd = 22;
                    } else {
                        shiftEnd = hour < 6 ? 6 : 6 + 24; // Next day 06:00
                    }
                    const minutesUntilEnd = (shiftEnd - hour) * 60 - time.getMinutes();
                    return { isProductionAllowed: true, minutesUntilEnd };
                    
                default:
                    return { isProductionAllowed: true, minutesUntilEnd: 24 * 60 };
            }
        }

        function getNextProductionWindow(currentTime, productionWindow) {
            const hour = currentTime.getHours();
            const nextWindow = new Date(currentTime);
            
            switch (productionWindow) {
                case '24x7':
                    return currentTime; // Always available
                    
                case '2-shift':
                    if (hour >= 22 || hour < 6) {
                        // Move to next day 06:00
                        nextWindow.setDate(nextWindow.getDate() + (hour >= 22 ? 1 : 0));
                        nextWindow.setHours(6, 0, 0, 0);
                    }
                    return nextWindow;
                    
                case '3-shift':
                    // Move to next shift boundary
                    if (hour >= 6 && hour < 14) {
                        nextWindow.setHours(14, 0, 0, 0);
                    } else if (hour >= 14 && hour < 22) {
                        nextWindow.setHours(22, 0, 0, 0);
                    } else {
                        nextWindow.setDate(nextWindow.getDate() + 1);
                        nextWindow.setHours(6, 0, 0, 0);
                    }
                    return nextWindow;
                    
                default:
                    return currentTime;
            }
        }

        function alignToSetupWindow(time, setupWindow) {
            const hour = time.getHours();
            const date = new Date(time.getFullYear(), time.getMonth(), time.getDate());
            
            if (hour < setupWindow.start) {
                // Before window, move to start
                return new Date(date.getTime() + (setupWindow.start * 60 * 60 * 1000));
            } else if (hour >= setupWindow.end) {
                // After window, move to next day start
                return new Date(date.getTime() + (24 + setupWindow.start) * 60 * 60 * 1000);
            }
            return time; // Within window
        }

        function scheduleSetupWithinWindow(startTime, durationMinutes, setupWindow) {
            let currentTime = new Date(startTime);
            let remainingTime = durationMinutes;
            let totalPausedTime = 0;
            const actualStart = new Date(currentTime);
            
            while (remainingTime > 0) {
                const hour = currentTime.getHours();
                
                // Check if we're within setup window
                if (hour < setupWindow.start || hour >= setupWindow.end) {
                    // Outside window, move to next window start
                    const date = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());
                    let nextWindowStart;
                    
                    if (hour < setupWindow.start) {
                        nextWindowStart = new Date(date.getTime() + (setupWindow.start * 60 * 60 * 1000));
                    } else {
                        nextWindowStart = new Date(date.getTime() + (24 + setupWindow.start) * 60 * 60 * 1000);
                    }
                    
                    const pauseTime = (nextWindowStart.getTime() - currentTime.getTime()) / (60 * 1000);
                    totalPausedTime += pauseTime;
                    currentTime = nextWindowStart;
                    continue;
                }
                
                // Calculate time available in current window
                const windowEndTime = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate(), setupWindow.end);
                const availableInWindow = Math.max(0, (windowEndTime.getTime() - currentTime.getTime()) / (60 * 1000));
                
                if (availableInWindow >= remainingTime) {
                    // Can complete setup in current window
                    currentTime = new Date(currentTime.getTime() + (remainingTime * 60 * 1000));
                    remainingTime = 0;
                } else {
                    // Need to continue in next window
                    remainingTime -= availableInWindow;
                    currentTime = windowEndTime;
                }
            }
            
            return {
                start: actualStart,
                end: currentTime,
                pausedTime: totalPausedTime
            };
        }

        function scheduleRunContinuous(startTime, durationMinutes) {
            // Run phase can continue 24/7, only paused by breakdowns/holidays
            const endTime = new Date(startTime.getTime() + (durationMinutes * 60 * 1000));
            
            // Check for breakdown machines and holidays from advanced settings
            let pausedTime = 0;
            
            // Add breakdown time if applicable
            if (advancedSettings.breakdownDateTime) {
                // Parse breakdown time and add to paused time
                // This is a simplified implementation
                pausedTime += 60; // Assume 1 hour breakdown
            }
            
            return {
                start: startTime,
                end: new Date(endTime.getTime() + (pausedTime * 60 * 1000)),
                pausedTime: pausedTime
            };
        }

        function scheduleWithinShifts(startTime, durationMinutes) {
            let currentTime = new Date(startTime);
            let remainingTime = durationMinutes;
            let totalPausedTime = 0;
            const actualStart = new Date(currentTime);
            
            while (remainingTime > 0) {
                const shiftEnd = getShiftEnd(currentTime);
                const availableInShift = Math.max(0, (shiftEnd.getTime() - currentTime.getTime()) / (60 * 1000));
                
                if (availableInShift >= remainingTime) {
                    // Can complete in current shift
                    currentTime = new Date(currentTime.getTime() + (remainingTime * 60 * 1000));
                    remainingTime = 0;
                } else {
                    // Need to continue in next shift
                    remainingTime -= availableInShift;
                    const nextShiftStart = getNextShiftAfter(shiftEnd);
                    const pauseTime = (nextShiftStart.getTime() - shiftEnd.getTime()) / (60 * 1000);
                    totalPausedTime += pauseTime;
                    currentTime = nextShiftStart;
                }
            }
            
            return {
                start: actualStart,
                end: currentTime,
                pausedTime: totalPausedTime
            };
        }

        function getShiftEnd(time) {
            const date = new Date(time.getFullYear(), time.getMonth(), time.getDate());
            const hour = time.getHours();
            
            if (hour < 14) {
                // Morning shift ends at 14:00
                return new Date(date.getTime() + (14 * 60 * 60 * 1000));
            } else {
                // Evening shift ends at 22:00
                return new Date(date.getTime() + (22 * 60 * 60 * 1000));
            }
        }

        function getNextShiftAfter(time) {
            const date = new Date(time.getFullYear(), time.getMonth(), time.getDate());
            const hour = time.getHours();
            
            if (hour < 6) {
                // Next shift is morning at 06:00
                return new Date(date.getTime() + (6 * 60 * 60 * 1000));
            } else if (hour < 14) {
                // Next shift is evening at 14:00
                return new Date(date.getTime() + (14 * 60 * 60 * 1000));
            } else {
                // Next shift is tomorrow morning at 06:00
                return new Date(date.getTime() + (24 + 6) * 60 * 60 * 1000);
            }
        }

        function alignToShiftStart(time) {
            const hour = time.getHours();
            const date = new Date(time.getFullYear(), time.getMonth(), time.getDate());
            
            if (hour < 6) {
                return new Date(date.getTime() + (6 * 60 * 60 * 1000)); // 06:00
            } else if (hour < 14) {
                return time; // Already in morning shift
            } else if (hour < 22) {
                return time; // Already in evening shift
            } else {
                return new Date(date.getTime() + (24 + 6) * 60 * 60 * 1000); // Next day 06:00
            }
        }

        function formatTiming(totalElapsedMs, pausedTimeMinutes) {
            const totalMinutes = Math.floor(totalElapsedMs / (60 * 1000));
            const days = Math.floor(totalMinutes / (24 * 60));
            const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
            const minutes = totalMinutes % 60;
            
            let result = "";
            if (days > 0) result += `${days}d `;
            if (hours > 0) result += `${hours}h `;
            if (minutes > 0) result += `${minutes}m`;
            
            if (pausedTimeMinutes > 0) {
                const pausedHours = Math.floor(pausedTimeMinutes / 60);
                result += ` (paused ${pausedHours}h due to shift gaps)`;
            }
            
            return result.trim();
        }

        function formatDateTime(date) {
            if (!date || !(date instanceof Date)) {
                console.error('Invalid date passed to formatDateTime:', date);
                return 'Invalid Date';
            }
            
            // Force local timezone display instead of UTC
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            
            const formatted = `${year}-${month}-${day} ${hours}:${minutes}`;
            console.log('Formatting date:', date.toISOString(), '→', formatted);
            return formatted;
        }

        function formatDate(dateString) {
            return new Date(dateString).toISOString().slice(0, 10);
        }

        function formatDuration(minutes) {
            if (minutes < 60) {
                return `${Math.round(minutes)}M`;
            }
            
            const totalMinutes = Math.round(minutes);
            const days = Math.floor(totalMinutes / (24 * 60));
            const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
            const mins = totalMinutes % 60;
            
            let result = '';
            if (days > 0) result += `${days}D `;
            if (hours > 0) result += `${hours}H `;
            if (mins > 0) result += `${mins}M`;
            
            return result.trim() || '0M';
        }

        function getBreakdownMachines() {
            const select = document.getElementById('breakdownMachines');
            if (!select) return [];
            return Array.from(select.selectedOptions).map(option => option.value);
        }

        function getBreakdownDateTime() {
            const input = document.getElementById('breakdownDateTime');
            return input ? input.value : '';
        }

        function getStartDateTime() {
            const input = document.getElementById('startDateTime');
            return input ? new Date(input.value) : new Date();
        }

        function getHolidays() {
            const input = document.getElementById('holidays');
            if (!input || !input.value) return [];
            return input.value.split(',').map(date => date.trim());
        }

        function getSetupWindow() {
            const input = document.getElementById('setupAvailabilityWindow');
            return input ? input.value : '06:00-22:00';
        }

        function getShifts() {
            return {
                shift1: document.getElementById('shift1')?.value || '06:00-14:00',
                shift2: document.getElementById('shift2')?.value || '14:00-22:00',
                shift3: document.getElementById('shift3')?.value || '22:00-06:00'
            };
        }

        function calculatePieceLevelScheduling(operations, order, machineSchedule, operatorSchedule) {
            const results = [];
            const batchQty = order.quantity;
            let previousOpPieceCompletionTimes = []; // Track when each piece completes from previous operation
            
            // Get order-specific settings
            const orderSettings = getOrderSettings(order);
            
            operations.forEach((operation, opIndex) => {
                // Select machine and operator for this operation
                const selectedMachine = selectOptimalMachine(operation, machineSchedule, orderSettings);
                const selectedOperator = selectOptimalOperator(operatorSchedule, machineSchedule[selectedMachine], orderSettings);
                
                // Setup Rule: Setup starts when first piece from previous operation is completed
                let setupStartTime;
                if (opIndex === 0) {
                    // First operation - setup starts based on machine/operator availability
                    setupStartTime = new Date(Math.max(
                        machineSchedule[selectedMachine]?.getTime() || 0,
                        operatorSchedule[selectedOperator]?.getTime() || 0,
                        new Date('2025-09-01T06:00:00').getTime() // Fixed start time
                    ));
                } else {
                    // Subsequent operations - setup starts when first piece from previous op is done
                    // CRITICAL FIX: Use the first piece completion time from previous operation
                    const firstPieceFromPrevOp = previousOpPieceCompletionTimes[0];
                    setupStartTime = new Date(Math.max(
                        firstPieceFromPrevOp?.getTime() || 0,
                        machineSchedule[selectedMachine]?.getTime() || 0,
                        operatorSchedule[selectedOperator]?.getTime() || 0
                    ));
                }
                
                // Apply setup window constraints - FIXED: Handle undefined setupWindow
                let setupStart, setupEnd;
                try {
                    const setupSchedule = calculateShiftAwareSchedule(
                        setupStartTime,
                        setupStartTime,
                        operation.SetupTime_Min,
                        0, // No run time for setup phase
                        orderSettings
                    );
                    setupStart = setupSchedule.setupStart;
                    setupEnd = setupSchedule.setupEnd;
                } catch (error) {
                    console.error('Error in setup scheduling:', error);
                    // Fallback: simple setup calculation without shift constraints
                    setupStart = new Date(setupStartTime);
                    setupEnd = new Date(setupStart.getTime() + operation.SetupTime_Min * 60000);
                }
                
                // Machine becomes available after setup
                let machineAvailableTime = new Date(setupEnd);
                
                // Piece Flow Rule: Process each piece individually
                const pieceRunTimes = [];
                const pieceCompletionTimes = [];
                
                // CRITICAL FIX: Initialize machine availability for piece processing
                let currentMachineTime = new Date(setupEnd);
                
                for (let pieceIndex = 0; pieceIndex < batchQty; pieceIndex++) {
                    // When is this piece ready from previous operation?
                    let pieceReadyTime;
                    if (opIndex === 0) {
                        // First operation - all pieces ready at setup end
                        pieceReadyTime = new Date(setupEnd);
                    } else {
                        // Piece ready when it completed previous operation
                        pieceReadyTime = previousOpPieceCompletionTimes[pieceIndex] || new Date(setupEnd);
                    }
                    
                    // CRITICAL FIX: RunStartTime = max(PieceReadyTime, CurrentMachineTime)
                    // This ensures pieces are processed sequentially on the machine
                    const runStartTime = new Date(Math.max(
                        pieceReadyTime.getTime(),
                        currentMachineTime.getTime()
                    ));
                    
                    // RunEndTime = RunStartTime + CycleTime
                    const runEndTime = new Date(runStartTime.getTime() + operation.CycleTime_Min * 60000);
                    
                    pieceRunTimes.push({
                        piece: pieceIndex + 1,
                        runStart: runStartTime,
                        runEnd: runEndTime
                    });
                    
                    pieceCompletionTimes.push(runEndTime);
                    
                    // CRITICAL FIX: Update machine time for next piece (sequential processing)
                    currentMachineTime = new Date(runEndTime);
                }
                
                // Operation completion times
                const firstPieceDone = pieceCompletionTimes[0];
                const lastPieceDone = pieceCompletionTimes[batchQty - 1];
                const operationRunStart = pieceRunTimes[0].runStart;
                const operationRunEnd = lastPieceDone;
                
                // Calculate timing description
                const totalElapsed = (operationRunEnd.getTime() - setupStart.getTime()) / (1000 * 60);
                const actualWork = operation.SetupTime_Min + (operation.CycleTime_Min * batchQty);
                const pausedTime = totalElapsed - actualWork;
                
                results.push({
                    OperationSeq: operation.OperationSeq,
                    OperationName: operation.OperationName,
                    Machine: selectedMachine,
                    Person: selectedOperator,
                    SetupStart: setupStart,
                    SetupEnd: setupEnd,
                    RunStart: operationRunStart,
                    RunEnd: operationRunEnd,
                    actualRunEnd: operationRunEnd, // For updating schedules
                    FirstPieceDone: firstPieceDone,
                    LastPieceDone: lastPieceDone,
                    PieceDetails: pieceRunTimes,
                    Timing: `${formatDuration(totalElapsed)} total (${pausedTime > 0 ? formatDuration(pausedTime) + ' paused, ' : ''}${formatDuration(actualWork)} work)`
                });
                
                // Update previous operation piece completion times for next iteration
                previousOpPieceCompletionTimes = pieceCompletionTimes;
            });
            
            return results;
        }

        function getOrderSettings(order) {
            // Get global settings
            const globalSettings = {
                breakdownMachines: getBreakdownMachines(),
                breakdownDateTime: getBreakdownDateTime(),
                startDateTime: getStartDateTime(),
                holidays: getHolidays(),
                setupWindow: getSetupWindow(),
                shifts: getShifts()
            };

            // Override with order-specific settings if provided
            const orderSettings = { ...globalSettings };

            if (order.breakdownMachine) {
                orderSettings.breakdownMachines = [order.breakdownMachine];
            }
            if (order.breakdownDateTime) {
                orderSettings.breakdownDateTime = order.breakdownDateTime;
            }
            if (order.startDateTime) {
                orderSettings.startDateTime = new Date(order.startDateTime);
            }
            if (order.holidayRange) {
                orderSettings.holidays = [order.holidayRange];
            }
            if (order.setupWindow) {
                orderSettings.setupWindow = order.setupWindow;
            }

            return orderSettings;
        }

        function selectOptimalMachine(operation, machineSchedule, orderSettings = null) {
            let eligibleMachines = operation.EligibleMachines;
            
            // Convert string to array if needed (EligibleMachines is stored as comma-separated string)
            if (typeof eligibleMachines === 'string') {
                eligibleMachines = eligibleMachines.split(',').map(m => m.trim());
            }
            
            // Filter out breakdown machines (use order-specific or global)
            const breakdownMachines = orderSettings ? orderSettings.breakdownMachines : getBreakdownMachines();
            const availableMachines = eligibleMachines.filter(machine => 
                !breakdownMachines.includes(machine)
            );
            
            if (availableMachines.length === 0) {
                return eligibleMachines[0]; // Fallback to first eligible if all are broken
            }
            
            // Select machine with earliest availability
            return availableMachines.reduce((best, current) => {
                const bestTime = machineSchedule[best] || new Date();
                const currentTime = machineSchedule[current] || new Date();
                return currentTime < bestTime ? current : best;
            });
        }

        function selectOptimalOperator(operatorSchedule, machineStartTime, orderSettings = null) {
            // Use order-specific shifts or fall back to global
            const shifts = orderSettings ? orderSettings.shifts : getShifts();
            
            // Parse shift times from settings
            const shift1 = parseShiftTime(shifts.shift1); // 06:00-14:00 -> A, B
            const shift2 = parseShiftTime(shifts.shift2); // 14:00-22:00 -> C, D
            const shift3 = parseShiftTime(shifts.shift3); // 22:00-06:00 -> Optional
            
            const startTime = new Date(Math.max(machineStartTime.getTime(), Date.now()));
            
            // Determine which shift the setup will occur in
            const hour = startTime.getHours();
            const minute = startTime.getMinutes();
            const timeInMinutes = hour * 60 + minute;
            
            let availableOperators = [];
            
            // Check which shift we're in
            if (timeInMinutes >= shift1.start && timeInMinutes < shift1.end) {
                availableOperators = ['A', 'B'];
            } else if (timeInMinutes >= shift2.start && timeInMinutes < shift2.end) {
                availableOperators = ['C', 'D'];
            } else if (shift3.enabled && (timeInMinutes >= shift3.start || timeInMinutes < shift3.end)) {
                availableOperators = ['A', 'B']; // Fallback to A, B for night shift
            } else {
                availableOperators = ['A', 'B']; // Default fallback
            }
            
            // Select operator with earliest availability
            return availableOperators.reduce((best, current) => {
                const bestTime = operatorSchedule[best] || new Date();
                const currentTime = operatorSchedule[current] || new Date();
                return currentTime < bestTime ? current : best;
            });
        }

        function parseShiftTime(shiftString) {
            const [start, end] = shiftString.split('-');
            return {
                start: parseInt(start.split(':')[0]) * 60 + parseInt(start.split(':')[1]),
                end: parseInt(end.split(':')[0]) * 60 + parseInt(end.split(':')[1])
            };
        }

        function parseSetupWindow(windowString) {
            if (!windowString || typeof windowString !== 'string') {
                console.error('Invalid setup window string:', windowString);
                return { start: 6, end: 22 }; // Default fallback
            }
            
            const [start, end] = windowString.split('-');
            if (!start || !end) {
                console.error('Invalid setup window format:', windowString);
                return { start: 6, end: 22 }; // Default fallback
            }
            
            const startParts = start.split(':');
            const endParts = end.split(':');
            
            if (!startParts[0] || !endParts[0]) {
                console.error('Invalid time format in setup window:', windowString);
                return { start: 6, end: 22 }; // Default fallback
            }
            
            const startHour = parseInt(startParts[0]);
            const endHour = parseInt(endParts[0]);
            
            if (isNaN(startHour) || isNaN(endHour)) {
                console.error('Invalid hour values in setup window:', windowString);
                return { start: 6, end: 22 }; // Default fallback
            }
            
            console.log('Parsed Setup Window:', { start: startHour, end: endHour, original: windowString });
            
            return {
                start: startHour,
                end: endHour
            };
        }

        function displayResults() {
            const resultsCard = document.getElementById('resultsCard');
            const alertsContainer = document.getElementById('scheduleAlerts');
            const tbody = document.getElementById('resultsTableBody');

            // Display alerts if any
            if (scheduleResults.alerts && scheduleResults.alerts.length > 0) {
                alertsContainer.innerHTML = scheduleResults.alerts.map(alert => 
                    `<div class="alert alert-error">${alert}</div>`
                ).join('');
            } else {
                alertsContainer.innerHTML = '';
            }

            // Display results table
            if (scheduleResults.rows && scheduleResults.rows.length > 0) {
                tbody.innerHTML = scheduleResults.rows.map(row => {
                    // Determine status based on due date comparison
                    let status = '✅';
                    let statusClass = 'status-success';
                    
                    if (row.DueDate && row.DueDate !== '2026-01-01 ⚠️') {
                        const dueDate = new Date(row.DueDate);
                        const runEnd = new Date(row.RunEnd);
                        
                        if (runEnd > dueDate) {
                            status = '❌';
                            statusClass = 'status-danger';
                        } else if (runEnd.getTime() - dueDate.getTime() < 24 * 60 * 60 * 1000) { // Within 24 hours
                            status = '⚠️';
                            statusClass = 'status-warning';
                        }
                    } else if (row.DueDate === '2026-01-01 ⚠️') {
                        status = '⚠️';
                        statusClass = 'status-warning';
                    }
                    
                    // Determine priority class
                    const priorityClass = `priority-${row.Priority ? row.Priority.toLowerCase() : 'normal'}`;
                    
                    return `
                        <tr class="${priorityClass}">
                        <td>${row.PartNumber}</td>
                        <td>${row.Order_Quantity}</td>
                            <td>${row.Priority || 'Normal'}</td>
                        <td>${row.Batch_ID}</td>
                        <td>${row.Batch_Qty}</td>
                        <td>${row.OperationSeq}</td>
                        <td>${row.OperationName}</td>
                        <td>${row.Machine}</td>
                        <td>${row.Person}</td>
                        <td class="nowrap">${row.SetupStart}</td>
                        <td class="nowrap">${row.SetupEnd}</td>
                        <td class="nowrap">${row.RunStart}</td>
                        <td class="nowrap">${row.RunEnd}</td>
                        <td class="nowrap">${row.Timing}</td>
                        <td class="nowrap">${row.DueDate}</td>
                            <td class="${statusClass}">${status}</td>
                    </tr>
                    `;
                }).join('');
            } else {
                tbody.innerHTML = '<tr><td colspan="16" style="text-align: center; color: #888;">No results to display</td></tr>';
            }

            resultsCard.style.display = 'block';
            resultsCard.scrollIntoView({ behavior: 'smooth' });
        }

        async function exportToExcel() {
            if (!scheduleResults.rows || scheduleResults.rows.length === 0) {
                alert('No data to export');
                return;
            }

            try {
                const userRole = await getCurrentUserRole();
                
                // For Test Users, only export if they're using test data
                if (userRole === 'Test User' && !isUsingTestData) {
                    showAlert('Test users must import Excel data first before exporting', 'error');
                    return;
                }

                // Use the enhanced ExcelExporter class
                const exporter = new ExcelExporter();
                const result = exporter.exportToExcel(scheduleResults);
                
                if (result.success) {
                    const dataSource = isUsingTestData ? ' (from uploaded Excel)' : ' (from database)';
                    showAlert(`Excel file exported successfully! Filename: ${result.filename}${dataSource}`, 'success');
                    
                    // Log export statistics
                    const stats = exporter.getExportStats(scheduleResults);
                    console.log('Export Statistics:', stats);
                } else {
                    showAlert(`Error exporting to Excel: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Export error:', error);
                showAlert('Error exporting to Excel: ' + error.message, 'error');
            }
        }

        // Global variables for role-based data management
        let currentUserRole = null;
        let testUserData = null; // In-memory data for Test Users
        let isUsingTestData = false;

        // Role-based Excel Import Function
        async function importFromExcel() {
            try {
                // Get current user role
                const userRole = await getCurrentUserRole();
                
                if (userRole === 'Operator') {
                    showAlert('Operators cannot import Excel files. Contact your administrator.', 'error');
                    return;
                }

                // Create file input element
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.xlsx,.xls';
                fileInput.style.display = 'none';
                
                fileInput.onchange = async function(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        showAlert('Processing Excel file...', 'info');
                        
                        // Parse Excel file
                        const excelData = await parseExcelFile(file);
                        
                        if (userRole === 'Admin') {
                            // Admin: Import to database
                            await importToDatabase(excelData);
                            showAlert('Excel data imported to database successfully!', 'success');
                            
                            // Refresh the operations data from database
                            await refreshOperationsFromDB();
                            
                        } else if (userRole === 'Test User') {
                            // Test User: Keep in memory only
                            testUserData = excelData;
                            isUsingTestData = true;
                            
                            // Update UI to show test data
                            updateUIForTestData();
                            showAlert('Excel data loaded for testing (not saved to database)', 'info');
                        }
                        
                    } catch (error) {
                        console.error('Import error:', error);
                        showAlert('Error importing Excel file: ' + error.message, 'error');
                    }
                };
                
                // Trigger file selection
                document.body.appendChild(fileInput);
                fileInput.click();
                document.body.removeChild(fileInput);
                
            } catch (error) {
                console.error('Import initialization error:', error);
                showAlert('Error initializing import: ' + error.message, 'error');
            }
        }

        // Get current user role from Supabase
        async function getCurrentUserRole() {
            if (currentUserRole) return currentUserRole;
            
            try {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) throw new Error('No active session');
                
                const { data: profile, error } = await supabase
                    .from('profiles')
                    .select('role')
                    .eq('id', session.user.id)
                    .single();
                
                if (error) throw error;
                
                currentUserRole = profile.role;
                return currentUserRole;
            } catch (error) {
                console.error('Error getting user role:', error);
                return 'Operator'; // Default fallback
            }
        }

        // Parse Excel file using SheetJS
        async function parseExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        // Load SheetJS library if not already loaded
                        if (typeof XLSX === 'undefined') {
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                            script.onload = () => parseExcelData(e.target.result, resolve, reject);
                            document.head.appendChild(script);
                        } else {
                            parseExcelData(e.target.result, resolve, reject);
                        }
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsArrayBuffer(file);
            });
        }

        function parseExcelData(arrayBuffer, resolve, reject) {
            try {
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet);
                
                // Validate and normalize the data
                const normalizedData = jsonData.map(row => ({
                    partnumber: row.PartNumber || row.partnumber || '',
                    operationseq: parseInt(row.OperationSeq || row.operationseq) || 0,
                    operationname: row.OperationName || row.operationname || '',
                    setuptime_min: parseInt(row.SetupTime_Min || row.setuptime_min) || 0,
                    operator: row.Operater || row.operator || '', // Note: Excel has "Operater" typo
                    cycletime_min: parseInt(row.CycleTime_Min || row.cycletime_min) || 0,
                    minimum_batchsize: parseInt(row.Minimum_BatchSize || row.minimum_batchsize) || 1,
                    eligiblemachines: Array.isArray(row.EligibleMachines) ? row.EligibleMachines : 
                                    (row.EligibleMachines || row.eligiblemachines || '').split(',').map(m => m.trim()).filter(m => m)
                }));
                
                // Validate required fields
                const invalidRows = normalizedData.filter(row => !row.partnumber || !row.operationseq);
                if (invalidRows.length > 0) {
                    throw new Error(`Invalid data: ${invalidRows.length} rows missing PartNumber or OperationSeq`);
                }
                
                resolve(normalizedData);
            } catch (error) {
                reject(new Error('Failed to parse Excel data: ' + error.message));
            }
        }

        // Import data to Supabase database (Admin only)
        async function importToDatabase(data) {
            try {
                // Clear existing data first
                const { error: deleteError } = await supabase
                    .from('master_operations')
                    .delete()
                    .neq('partnumber', ''); // Delete all rows
                
                if (deleteError) throw deleteError;
                
                // Insert new data in batches
                const batchSize = 100;
                for (let i = 0; i < data.length; i += batchSize) {
                    const batch = data.slice(i, i + batchSize);
                    const { error } = await supabase
                        .from('master_operations')
                        .insert(batch);
                    
                    if (error) throw error;
                }
                
            } catch (error) {
                throw new Error('Database import failed: ' + error.message);
            }
        }

        // Update UI for Test User data
        function updateUIForTestData() {
            // Store original OP_MASTER before overriding
            if (!window.originalOpMaster && window.OP_MASTER) {
                window.originalOpMaster = [...window.OP_MASTER];
            }
            
            // Add visual indicator that test data is being used
            const indicator = document.createElement('div');
            indicator.id = 'testDataIndicator';
            indicator.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                background: #ff9800;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            `;
            indicator.textContent = '🧪 TEST MODE - Using uploaded Excel data';
            
            // Remove existing indicator if present
            const existing = document.getElementById('testDataIndicator');
            if (existing) existing.remove();
            
            document.body.appendChild(indicator);
            
            // Update part number search to use test data
            if (testUserData) {
                setupPartNumberSearchForTestData();
            }
        }

        // Setup part number search for test data
        function setupPartNumberSearchForTestData() {
            const partNumbers = [...new Set(testUserData.map(op => op.partnumber))];
            
            // Override the getAvailablePartNumbers function
            window.getAvailablePartNumbers = function() {
                return partNumbers;
            };
            
            // Override the global OP_MASTER for test data
            window.OP_MASTER = testUserData.map(op => ({
                PartNumber: op.partnumber,
                OperationSeq: op.operationseq,
                OperationName: op.operationname,
                SetupTime_Min: op.setuptime_min,
                Operator: op.operator,
                CycleTime_Min: op.cycletime_min,
                Minimum_BatchSize: op.minimum_batchsize,
                EligibleMachines: op.eligiblemachines
            }));
            
            // Re-enable part number input for test users after import
            const partNumberInput = document.getElementById('partNumber');
            if (partNumberInput) {
                partNumberInput.disabled = false;
                partNumberInput.placeholder = 'Search part numbers...';
            }
            
            // Refresh the part number search
            setupPartNumberSearch();
        }

        // Refresh operations from database (for Admin/Operator)
        async function refreshOperationsFromDB() {
            try {
                const { data, error } = await supabase
                    .from('master_operations')
                    .select('*')
                    .order('partnumber', { ascending: true })
                    .order('operationseq', { ascending: true });
                
                if (error) throw error;
                
                // Update global operations data
                window.operationsData = data;
                
                // Refresh part number search
                setupPartNumberSearch();
                
            } catch (error) {
                console.error('Error refreshing operations:', error);
                showAlert('Error refreshing data from database', 'error');
            }
        }

        // Update user role indicator in UI
        async function updateUserRoleIndicator() {
            try {
                const userRole = await getCurrentUserRole();
                const indicator = document.getElementById('userRoleIndicator');
                
                if (indicator) {
                    indicator.textContent = userRole;
                    
                    // Style based on role
                    switch(userRole) {
                        case 'Admin':
                            indicator.style.backgroundColor = '#dc3545';
                            indicator.style.color = 'white';
                            break;
                        case 'Operator':
                            indicator.style.backgroundColor = '#28a745';
                            indicator.style.color = 'white';
                            break;
                        case 'Test User':
                            indicator.style.backgroundColor = '#ff9800';
                            indicator.style.color = 'white';
                            break;
                        default:
                            indicator.style.backgroundColor = '#6c757d';
                            indicator.style.color = 'white';
                    }
                }
            } catch (error) {
                console.error('Error updating user role indicator:', error);
            }
        }

        // Clear test data when user logs out (for Test Users)
        async function clearTestUserData() {
            testUserData = null;
            isUsingTestData = false;
            
            // Remove test data indicator
            const indicator = document.getElementById('testDataIndicator');
            if (indicator) indicator.remove();
            
            // Check if current user is Test User
            const userRole = await getCurrentUserRole();
            if (userRole === 'Test User') {
                // For Test Users, clear everything and setup empty state
                window.OP_MASTER = [];
                setupEmptyPartNumberSearch();
            } else {
                // For Admin/Operator, reset to original database data
                if (window.originalOpMaster) {
                    window.OP_MASTER = window.originalOpMaster;
                }
                setupPartNumberSearch();
            }
        }

        // Logout function with test data cleanup
        async function logout() {
            try {
                // Clear test user data if present
                clearTestUserData();
                
                // Sign out from Supabase
                const { error } = await supabase.auth.signOut();
                if (error) {
                    console.error('Logout error:', error);
                    showAlert('Error during logout: ' + error.message, 'error');
                    return;
                }
                
                // Redirect to auth page with logout parameter
                window.location.href = 'auth.html?logged_out=true';
                
            } catch (error) {
                console.error('Logout error:', error);
                showAlert('Error during logout: ' + error.message, 'error');
            }
        }

        // Clear session data based on user role
        async function clearSession() {
            try {
                const userRole = await getCurrentUserRole();
                
                // Show confirmation dialog
                const confirmMessage = userRole === 'Test User' 
                    ? 'This will clear all orders, results, and imported Excel data. Continue?'
                    : 'This will clear all orders and results. Continue?';
                
                if (!confirm(confirmMessage)) return;
                
                // Clear saved orders
                savedOrders = [];
                updateOrdersTable();
                
                // Clear schedule results
                scheduleResults = { rows: [], alerts: [] };
                document.getElementById('resultsCard').style.display = 'none';
                document.getElementById('exportBtn').disabled = true;
                
                // Clear form
                resetForm();
                
                // For Test Users, also clear imported Excel data
                if (userRole === 'Test User') {
                    await clearTestUserData();
                    showAlert('Session cleared. All orders, results, and imported data removed.', 'success');
                } else {
                    showAlert('Session cleared. All orders and results removed.', 'success');
                }
                
            } catch (error) {
                console.error('Error clearing session:', error);
                showAlert('Error clearing session: ' + error.message, 'error');
            }
        }

        function showAlert(message, type) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            document.querySelector('.container').insertBefore(alertDiv, document.querySelector('.card'));
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // Google Sheets Integration
        const GOOGLE_SHEETS_API_URL = 'https://script.google.com/macros/s/AKfycbwm_sPgJPGB7MViA1jow68rb-pAZGJKqskXIQdFBnDY_0QfpI9ObiUCI8fFZmrM-qbPGQ/exec';
        let lastSyncTimestamp = null;
        let isRefreshing = false;

        // Auto-sync interval (optional - set to 0 to disable)
        const AUTO_SYNC_INTERVAL_MINUTES = 5; // Set to 0 to disable auto-sync

        // Shared success handler
        function applyRoutingData(data) {
            if (!(data && data.meta && data.items)) {
                throw new Error('Invalid response format from Google Sheets API');
            }
            updateLocalRoutingData(data.items);
            persistRoutingData();
            // Also push to local writer service to update data.js on disk
            pushToLocalWriter(data.items);
            const syncStatus = document.getElementById('syncStatus');
            const lastSyncEl = document.getElementById('lastSync');
            lastSyncTimestamp = new Date();
            persistLastSync(lastSyncTimestamp);
            syncStatus.textContent = '✅ Google Sheets (saved)';
            lastSyncEl.textContent = `Last sync: ${lastSyncTimestamp.toLocaleString()}`;
            document.getElementById('partNumber').value = '';
            document.getElementById('operationSeqDisplay').value = '';
            document.getElementById('operationSeqDisplay').placeholder = 'Select a part number first';
            document.getElementById('operationSeqBtn').disabled = true;
            showAlert(`Successfully synced ${data.meta.rowCount} routing records from Google Sheets`, 'success');
            console.log('Routing data synced:', {
                totalRows: data.meta.rowCount,
                lastSync: data.meta.lastSync,
                sheetName: data.meta.sheetName
            });
        }









    </script>
</body>
</html>
